/**
 * Context structure.
 *   @file, vars, code, ext: The set of output files.
 *   @ext_buf: The extra buffer.
 *   @ext_sz: The extra size.
 *   @defer: The defered declaration list.
 *   @idefer: The defered end of list iterator.
 *   @sig: The function signature.
 *   @tmp, lab, str: The temporary, label, and string numbers.
 *   @binds, funcs, types, decls, cases, dbgs: The map of bindings, types,
 *     declarations cases, and debugging.
 */
tydef st:ctx {
	st:io:file file, vars, code, ext;
	pt:void ext_buf;
	u32 ext_sz;

	pt:st:defer defer;
	pt:pt:st:defer idefer;

	pt:st:pl3:sig sig;
	u32 tmp, lab, str;
	st:map map, binds, funcs, types, decls, cases, dbgs;

	st:avl:root refs;
};

/**
 * Defered declaration structure.
 *   @decl: The declaration.
 *   @func: The function.
 *   @next: The next declaration.
 */
tydef st:defer {
	pt:st:pl3:decl decl;
	pt:st:pl3:func func;
	pt:st:defer next;
};


def[export] st:pl3:arch pl3:arch_x64 = { 8 };

/**
 * Generate LLVM bitcode.
 *   @top: The top-level.
 *   @path: The output path.
 */
def[export] e:str[void](pt:st:pl3:top top, cpt:char path) pl3:llvm = {
	var st:ctx ctx;
	var st:io:file file;
	var pt:st:pl3:unit unit;
	var pt:st:pl3:stmt stmt;
	var pt:st:defer defer;
	var pt:st:pl3:decl decl;
	var pt:st:pl3:func func;

	file = e:get(io:open(path, 0644 | io:mode:create | io:mode:trunc | io:mode:write));
	ctx_init(&ctx, file);
	onerr ctx_done(&ctx);

	e:get(io:fmt(file, "target triple = \"x86_64-pc-linux-gnu\"\n"));

	e:get(io:fmt(ctx.ext, "!llvm.module.flags = !{!0}\n"));
	e:get(io:fmt(ctx.ext, "!%u = !{i32 2, !\"Debug Info Version\", i32 3}\n", map_get(&ctx.dbgs, top)));

	// TODO just a bunch of varargs stuff
	e:get(io:fmt(file, "%%\"$args\" = type { i32, i32, i8*, i8* }\n"));
	e:get(io:fmt(file, "declare void @_getarg(i8*, i32, i8*)\n"));
	e:get(io:fmt(file, "declare void @llvm.va_start(i8*)\n"));

	// TODO syscall function kinda sucks
	e:get(io:fmt(ctx.ext, "define internal i64 @$syscall(i64, i64, i64, i64, i64, i64, i64, ...) local_unnamed_addr #0 {\n"));
	e:get(io:fmt(ctx.ext, "\t%%8 = tail call i64 asm sideeffect \"syscall\", \"={ax},{ax},{di},{si},{dx},{r10},{r8},{r9},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}\"(i64 %%0, i64 %%1, i64 %%2, i64 %%3, i64 %%4, i64 %%5, i64 %%6) #1\n"));
	e:get(io:fmt(ctx.ext, "\tret i64 %%8\n"));
	e:get(io:fmt(ctx.ext, "}\n"));

	for(unit = top->unit; unit != null; unit = unit->next) {
		for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
			if(stmt->tag == ev:pl3:stmt:decl) {
				var pt:st:pl3:bind bind;
				var pt:st:pl3:decl decl = stmt->data.decl;

				if(pl3:type_is_sig(decl->type)) {
					for(bind = decl->bind; bind != null; bind = bind->next) {
						if((decl->flags & pl3:decl:ext) != 0) {
							var pt:st:pl3:sig sig = decl->type.data.sig;
							var st:io:call param = call_pinfo(getref(st:pinfo{ &ctx, sig->param, sig->vlist })); //FIXME ugly

							def e:str[void](st:io:file file, cpt:void arg) proc = {
								e:get(io:fmt(file, "@\"%s\"", arg));
							};

							e:get(io:fmt(ctx.file, "declare %C @\"%s\"(%C)\n", call_type(&sig->ret), bind->id, param));
							ref_put(&ctx, bind, st:io:call{ &proc, bind->id });
							continue;
						}

						var pt:st:pl3:func func;
						var pt:st:pl3:expr expr = bind->expr;

						if(expr == null)
							e:fmt("Internal error. Cannot have an uninitialized function variable.");
						if(expr->tag != ev:pl3:expr:func)
							e:fmt("Internal error. Invalid function variable.");

						func = expr->data.func;
						if((decl->flags & pl3:decl:exp) != 0)
							ref_put(&ctx, func, ref_external(&ctx, bind));
						else
							ref_put(&ctx, bind, ref_uniq(&ctx, func));

						*ctx.idefer = mem:make(st:defer{ decl, func, null });
						ctx.idefer = &(*ctx.idefer)->next;
					}
				}
				else {
					for(bind = decl->bind; bind != null; bind = bind->next) {
						if((decl->flags & (pl3:decl:exp | pl3:decl:ext)) != 0)
							ref_external(&ctx, bind);
					}

					*ctx.idefer = mem:make(st:defer{ stmt->data.decl, null, null});
					ctx.idefer = &(*ctx.idefer)->next;
				}
			}
			else if(stmt->tag == ev:pl3:stmt:tydecl)
				e:get(emit_tydecl(&ctx, stmt->data.tydecl));
			else
				e:fmt("Code units can only contain declarations.");
		}
	}

	while(ctx.defer != null) {
		ctx.defer = (defer = ctx.defer)->next;
		decl = defer->decl;
		func = defer->func;
		mem:free(defer);
		if(ctx.defer == null)
			ctx.idefer = &ctx.defer;

		ctx.code = file;

		if(decl != null && func == null)
			e:get(ctx_top(&ctx, decl));

		if(func != null)
			e:get(ctx_func(&ctx, func, decl));
	}

	ctx_done(&ctx);
};


/**
 * Initialize the context.
 *   @ctx: The context.
 *   @file THe output file.
 */
def void(pt:st:ctx ctx, st:io:file file) ctx_init = {
	ctx->defer = null;
	ctx->file = file;
	ctx->ext = io:accum(&ctx->ext_buf, &ctx->ext_sz, 256);
	ctx->idefer = &ctx->defer;
	ctx->binds = map_new();
	ctx->types = map_new();
	ctx->decls = map_new();
	ctx->cases = map_new();
	ctx->dbgs = map_new();
	ctx->str = 0;
	ctx->refs = avl:root_new(&avl:cmp_ptr);
};

/**
 * Done with the context.
 *   @ctx: The context.
 */
def void(pt:st:ctx ctx) ctx_done = {
	var pt:st:defer defer;

	while(ctx->defer != null) {
		ctx->defer = (defer = ctx->defer)->next;
		mem:free(defer);
	}

	io:close(ctx->ext);
	io:write(ctx->file, ctx->ext_buf, ctx->ext_sz);
	mem:free(ctx->ext_buf);

	io:close(ctx->file);
	map_delete(ctx->binds);
	map_delete(ctx->types);
	map_delete(ctx->decls);
	map_delete(ctx->cases);
	map_delete(ctx->dbgs);
	avl:root_delete(&ctx->refs, offsetof(st:ref, node), &mem:free);
};


/**
 * Emit a type declaration.
 *   @ctx: The context.
 *   @decl: The type declation.
 */
def e:str[void](pt:st:ctx ctx, pt:st:pl3:tydecl decl) emit_tydecl = {
	switch(decl->tag) {
	case ev:pl3:tydecl:alias:
		break;

	case ev:pl3:tydecl:struct: {
		var u32 id;
		var pt:st:pl3:memb memb;
		var pt:st:pl3:field field;
		var pt:st:pl3:agg agg = decl->data.agg;

		for(memb = agg->memb; memb != null; memb = memb->next) {
			var en:pl3:tydecl tag;
			var pt:st:pl3:agg agg;
			var pt:st:pl3:name name;

			// TODO: this is kinda redundant
			name = pl3:type_get_name(memb->type);

			agg = pl3:type_get_agg(memb->type, &tag);
			if(agg == null)
				continue;

			if(map_find(&ctx->decls, agg) < 0)
				e:get(emit_tydecl(ctx, name->decl));
		}

		if(map_find(&ctx->decls, decl) >= 0)
			break;

		map_get(&ctx->decls, decl);
		id = map_get(&ctx->types, decl);
		e:get(io:fmt(ctx->file, "%%\"$s%u\" = type {", id));

		for(memb = agg->memb; memb != null; memb = memb->next) {
			for(field = memb->field; field != null; field = field->next) {
				var st:io:call type = call_tyinfo(getref(st:tyinfo{ ctx, memb->type }));

				e:get(io:fmt(ctx->file, "%C", type));

				if((field->next != null) || (memb->next != null))
					e:get(io:fmt(ctx->file, ", "));
			}
		}

		e:get(io:fmt(ctx->file, "}\n"));
	} break;

	case ev:pl3:tydecl:union:
		break;

	case ev:pl3:tydecl:enum:
		//FIXME emit symbols for the values
		break;
	}
};

/**
 * Emit a top-level.
 *   @ctx: The context.
 *   @decl: The declaration.
 */
def e:str[void](pt:st:ctx ctx, pt:st:pl3:decl decl) ctx_top = {
	var pt:st:pl3:bind bind;

	for(bind = decl->bind; bind != null; bind = bind->next) {
		if(decl->type.tag == ev:pl3:type:sig) {
			if(bind->expr != null) {
				var pt:st:pl3:func func;

				if(bind->expr->tag != ev:pl3:expr:func)
					e:fmt("Cannot emit non-function expression.");

				func = bind->expr->data.func;

				*ctx->idefer = mem:make(st:defer{ bind, func, null});
				ctx->idefer = &(*ctx->idefer)->next;

				//if((decl->flags & pl3:decl:exp) != 0)
					//e:get(io:fmt(ctx->file, "@\"%s\" = dso_local alias %C, %C* %C\n", bind->id, sig, sig, id));
				//else if((decl->flags & pl3:decl:pub) != 0)
					//e:get(io:fmt(ctx->file, "@\"%s\" = hidden alias %C, %C* %C\n", bind->id, sig, sig, id));

				if((decl->flags & pl3:decl:exp) != 0)
					ref_put(ctx, func, ref_external(ctx, bind));
				else
					ref_put(ctx, bind, ref_uniq(ctx, func));
			}
			else {
				var pt:st:pl3:sig sig = decl->type.data.sig;
				var st:io:call param = call_pinfo(getref(st:pinfo{ ctx, sig->param, sig->vlist })); //FIXME ugly

				def e:str[void](st:io:file file, cpt:void arg) proc = {
					e:get(io:fmt(file, "@\"%s\"", arg));
				};
				
				e:get(io:fmt(ctx->file, "declare %C @\"%s\"(%C)\n", call_type(&sig->ret), bind->id, param));
				ref_put(ctx, bind, st:io:call{ &proc, bind->id });
			}
		}
		else {
			if(bind->expr != null) {
				var st:env env;
				var st:map map;
				var st:scope scope;
				var st:io:call calc;

				map = map_new();
				onerr map_delete(map);

				scope = scope_new(null);
				onerr scope_delete(scope);

				env = st:env{ &map, null, &scope };

				calc = calc_expr(getref(st:calc{ ctx, &env, bind->expr }));

				if((decl->flags & pl3:decl:exp) != 0)
					ref_external(ctx, bind);

				e:get(io:fmt(ctx->file, "%C = global %C %C, !dbg %C\n", ref_bind(ctx, bind), call_type(&decl->type), calc, dbg_bind(ctx, bind, decl)));

				map_delete(map);
				scope_delete(scope);
			}
			else {
				if((decl->flags & pl3:decl:ext) != 0) {
					e:get(io:fmt(ctx->file, "@\"%s\" = external dso_local global %C\n", bind->id, call_type(&decl->type)));
					ref_external(ctx, bind);
					//e:get(io:fmt(ctx->file, "%C = external alias %C, %C* @\"%s\"\n", ref_bind(ctx, bind), call_type(&decl->type), call_type(&decl->type), bind->id));
				}
				else if((decl->flags & pl3:decl:exp) != 0) {
					e:get(io:fmt(ctx->file, "@\"%s\" = external global %C zeroinitializer, !dbg %C\n", bind->id, call_type(&decl->type), dbg_bind(ctx, bind, decl)));
					ref_external(ctx, bind);
				}
				else
					e:get(io:fmt(ctx->file, "%C = internal global %C zeroinitializer, !dbg %C\n", ref_bind(ctx, bind), call_type(&decl->type), dbg_bind(ctx, bind, decl)));
			}
		}
	}
};

/**
 * Emit a function.
 *   @ctx: The context.
 *   @func: The function.
 *   @name: The name.
 */
def e:str[void](pt:st:ctx ctx, pt:st:pl3:func func, pt:st:pl3:decl decl) ctx_func = {
	var u32 i;
	var st:map map;
	var st:env env;
	var st:scope scope;
	var pt:st:pl3:param param;
	var pt:void vars_buf, code_buf;
	var u32 vars_sz, code_sz;
	var st:io:call sig, name;

	sig = call_sig(func->sig);
	name = ref_uniq(ctx, func);

	ctx->vars = io:accum(&vars_buf, &vars_sz, 256);
	ctx->code = io:accum(&code_buf, &code_sz, 256);
	onerr { io:close(ctx->vars); mem:free(vars_buf); }
	onerr { io:close(ctx->code); mem:free(code_buf); }

	map = map_new();
	onerr map_delete(map);

	scope = scope_new(null);
	onerr scope_delete(scope);

	env = st:env{ &map, null, &scope };

	i = 0;
	for(param = func->sig->param; param != null; param = param->next) {
		var st:io:call mem, type;

		if(param->id == null)
			continue;

		mem = call_local(map_get(&map, param));
		type = call_tyinfo(getref(st:tyinfo{ ctx, param->type }));

		e:get(io:fmt(ctx->vars, "\t%C = alloca %C\n", mem, type));
		e:get(io:fmt(ctx->code, "\tstore %C %%a%u, %C* %C\n", type, i++, type, mem));
	}

	ctx->sig = func->sig;
	ctx->tmp = 0;
	ctx->lab = 0;
	e:get(ctx_block(ctx, &env, func->block));

	io:close(ctx->vars);
	io:close(ctx->code);

	if(pt:void{name.func} != pt:void{&ext_proc})
		e:get(io:fmt(ctx->file, "define internal %C %C(%C) {\n", call_type(&func->sig->ret), name, call_pinfo(getref(st:pinfo{ ctx, func->sig->param, func->sig->vlist }))));
	else
		e:get(io:fmt(ctx->file, "define %C %C(%C) {\n", call_type(&func->sig->ret), name, call_pinfo(getref(st:pinfo{ ctx, func->sig->param, func->sig->vlist }))));
	e:get(io:write(ctx->file, vars_buf, vars_sz));
	e:get(io:write(ctx->file, code_buf, code_sz));

	var pt:st:pl3:err err;
	if((err = pl3:type_get_err(func->sig->ret)) != null) {
		if(pl3:type_is_void(err->suc)) 
			e:get(io:fmt(ctx->file, "\tret %C zeroinitializer\n", call_type(&err->fail)));
		else
			e:get(io:fmt(ctx->file, "\tunreachable\n"));
	}
	else if(pl3:type_is_void(func->sig->ret))
		e:get(io:fmt(ctx->file, "\tret void\n"));
	else
		e:get(io:fmt(ctx->file, "\tunreachable\n"));

	e:get(io:fmt(ctx->file, "}\n"));

	mem:free(vars_buf);
	mem:free(code_buf);
	map_delete(map);
	scope_delete(scope);
};

/**
 * Emit a block.
 *   @ctx: The context.
 *   @block: The block.
 */
def e:str[void](pt:st:ctx ctx, pt:st:env env, st:pl3:block block) ctx_block = {
	var st:env nest;
	var st:scope scope;
	var pt:st:pl3:stmt stmt;

	scope = scope_new(env->scope);
	onerr scope_delete(scope);

	nest = st:env{ env->map, env->flow, &scope };

	for(stmt = block.stmt; stmt != null; stmt = stmt->next)
		e:get(ctx_stmt(ctx, &nest, stmt));

	scope_delete(scope);
};

/**
 * Emit a statement.
 *   @ctx: The context.
 *   @env: The environment.
 *   @stmt: The statement.
 */
def e:str[void](pt:st:ctx ctx, pt:st:env env, pt:st:pl3:stmt stmt) ctx_stmt = {
	switch(stmt->tag) {
	case ev:pl3:stmt:decl: {
		var pt:st:pl3:bind bind;
		var pt:st:pl3:decl decl = stmt->data.decl;

		if(pl3:type_is_sig(decl->type)) {
			for(bind = decl->bind; bind != null; bind = bind->next) {
				var pt:st:pl3:func func;
				var pt:st:pl3:expr expr = bind->expr;

				if(expr == null)
					e:fmt("Internal error. Cannot have an uninitialized function variable.");
				if(expr->tag != ev:pl3:expr:func)
					e:fmt("Internal error. Invalid function variable.");

				func = expr->data.func;
				if((decl->flags & pl3:decl:exp) != 0)
					ref_put(ctx, func, ref_external(ctx, bind));
				else
					ref_put(ctx, bind, ref_uniq(ctx, func));

				*ctx->idefer = mem:make(st:defer{ bind, func, null });
				ctx->idefer = &(*ctx->idefer)->next;
			}
		}
		else if((decl->flags & pl3:decl:mut) == 0) {
			*ctx->idefer = mem:make(st:defer{ decl, null, null });
			ctx->idefer = &(*ctx->idefer)->next;
		}
		else {
			for(bind = decl->bind; bind != null; bind = bind->next) {
				var st:io:call id = call_local(map_get(env->map, bind));
				var st:io:call type = call_tyinfo(getref(st:tyinfo{ ctx, decl->type }));

				e:get(io:fmt(ctx->vars, "\t%C = alloca %C\n", id, type));

				if(bind->expr != null) {
					var st:io:call val;

					val = e:get(ctx_expr(ctx, env, bind->expr));
					e:get(io:fmt(ctx->code, "\tstore %C %C, %C* %C\n", type, val, type, id));
				}
			}
		}
	} break;

	case ev:pl3:stmt:expr:
		e:get(ctx_expr(ctx, env, stmt->data.expr));
		break;

	case ev:pl3:stmt:ret: {
		var pt:st:pl3:err err;

		err = pl3:type_get_err(ctx->sig->ret);

		if(stmt->data.expr != null) {
			var st:io:call val, type;

			val = e:get(ctx_expr(ctx, env, stmt->data.expr));
			type = call_tyinfo(getref(st:tyinfo{ ctx, ctx->sig->ret }));

			if(err != null) {
				if(pl3:type_get_err(stmt->data.expr->type) == null) {
					var st:io:call ret, vty, ety;
					vty = call_tyinfo(getref(st:tyinfo{ ctx, err->suc }));
					ety = call_tyinfo(getref(st:tyinfo{ ctx, err->fail }));
					ret = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = insertvalue %C { %C undef, %C zeroinitializer }, %C %C, 0\n", ret, type, vty, ety, vty, val, pl3:meta_call(&stmt->meta)));
					e:get(io:fmt(ctx->code, "\tret %C %C\n", type, ret));
				}
				else
					e:get(io:fmt(ctx->code, "\tret %C %C\n", type, val));
			}
			else if(pl3:type_is_void(stmt->data.expr->type))
				e:get(io:fmt(ctx->code, "\tret void\n"));
			else
				e:get(io:fmt(ctx->code, "\tret %C %C\n", type, val));
		}
		else {
			if(err != null) {
				var st:io:call ety;

				ety = call_tyinfo(getref(st:tyinfo{ ctx, err->fail }));

				e:get(io:fmt(ctx->code, "\tret %C zeroinitializer\n", ety));
			}
			else
				e:get(io:fmt(ctx->code, "\tret void\n"));
		}
	} break;

	case ev:pl3:stmt:block:
		e:get(ctx_block(ctx, env, stmt->data.block));
		break;

	case ev:pl3:stmt:cond: {
		var st:io:call eval;
		var u32 ontrue, onfalse, after;
		var pt:st:pl3:cond cond = stmt->data.cond;

		after = ctx->lab++;
		ontrue = (cond->ontrue != null) ? ctx->lab++ : after;
		onfalse = (cond->onfalse != null) ? ctx->lab++ : after;

		eval = e:get(ctx_expr(ctx, env, cond->eval));	

		e:get(io:fmt(ctx->code, "\tbr i1 %C, label %%l%u, label %%l%u\n", e:get(mk_bool(ctx, eval)), ontrue, onfalse));

		if(cond->ontrue != null) {
			e:get(io:fmt(ctx->code, "l%u:\n", ontrue));
			e:get(ctx_stmt(ctx, env, cond->ontrue));
			e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", after));
		}

		if(cond->onfalse != null) {
			e:get(io:fmt(ctx->code, "l%u:\n", onfalse));
			e:get(ctx_stmt(ctx, env, cond->onfalse));
			e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", after));
		}

		e:get(io:fmt(ctx->code, "l%u:\n", after));
	} break;

	case ev:pl3:stmt:loop: {
		var u32 inc, begin, end;
		var st:env nest;
		var st:flow flow;
		var pt:st:pl3:loop loop = stmt->data.loop;

		if(loop->init != null)
			e:get(ctx_expr(ctx, env, loop->init));

		inc = ctx->lab++;
		begin = ctx->lab++;
		end = ctx->lab++;

		if(loop->post) {
			e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", begin));
			e:get(io:fmt(ctx->code, "l%u:\n", begin));

			flow = st:flow{ end, begin, env->flow };
			nest = st:env{ env->map, &flow, env->scope };
			e:get(ctx_stmt(ctx, &nest, loop->body));

			if(loop->inc != null)
				e:get(ctx_expr(ctx, env, loop->inc));

			if(loop->eval != null) {
				var u32 body;
				var st:io:call eval;

				body = ctx->lab++;
				eval = e:get(ctx_expr(ctx, env, loop->eval));
				e:get(io:fmt(ctx->code, "\tbr i1 %C, label %%l%u, label %%l%u\n", e:get(mk_bool(ctx, eval)), begin, end));
			}
			else
				e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", begin));

			e:get(io:fmt(ctx->code, "l%u:\n", end));
		}
		else {
			e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", begin));
			e:get(io:fmt(ctx->code, "l%u:\n", begin));

			if(loop->eval != null) {
				var u32 body;
				var st:io:call eval;

				body = ctx->lab++;
				eval = e:get(ctx_expr(ctx, env, loop->eval));
				e:get(io:fmt(ctx->code, "\tbr i1 %C, label %%l%u, label %%l%u\n", e:get(mk_bool(ctx, eval)), body, end));
				e:get(io:fmt(ctx->code, "l%u:\n", body));
			}

			flow = st:flow{ end, inc, env->flow };
			nest = st:env{ env->map, &flow, env->scope };
			e:get(ctx_stmt(ctx, &nest, loop->body));

			e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", inc));
			e:get(io:fmt(ctx->code, "l%u:\n", inc));

			if(loop->inc != null)
				e:get(ctx_expr(ctx, env, loop->inc));

			e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", begin));
			e:get(io:fmt(ctx->code, "l%u:\n", end));
		}
	} break;

	case ev:pl3:stmt:sw: {
		var pt:st:pl3:cas cas;
		var u32 after, other;
		var st:io:call type, eval;
		var st:env nest;
		var st:flow flow;
		var pt:st:pl3:sw sw = stmt->data.sw;

		after = ctx->lab++;

		if(sw->dflt != null) {
			other = map_get(&ctx->cases, sw->dflt);
		}
		else
			other = after;

		type = call_tyinfo(getref(st:tyinfo{ ctx, sw->eval->type }));
		eval = e:get(ctx_expr(ctx, env, sw->eval));
		e:get(io:fmt(ctx->code, "  switch %C %C, label %%%c%u [ ", type, eval, char{(sw->dflt != null) ? 'c' : 'l'}, other)); // TODO This feels stupid

		for(cas = sw->cas; cas != null; cas = cas->next) {
			var st:io:call type, val, calc;

			type = call_tyinfo(getref(st:tyinfo{ ctx, cas->expr->type }));
			calc = calc_expr(getref(st:calc{ ctx, env, cas->expr }));
			e:get(io:fmt(ctx->code, "%C %C, label %%c%u ", type, calc, map_get(&ctx->cases, cas)));
		}

		e:get(io:fmt(ctx->code, "] ; %C\n", pl3:meta_call(&stmt->meta)));
		e:get(io:fmt(ctx->code, "l%u:\n", ctx->lab++));

		flow = st:flow{ after, after, env->flow };
		nest = st:env{ env->map, &flow, env->scope };
		e:get(ctx_stmt(ctx, &nest, sw->stmt));

		e:get(io:fmt(ctx->code, "  br label %%l%u\n", after));
		e:get(io:fmt(ctx->code, "l%u:\n", after));
	} break;

	case ev:pl3:stmt:cas: {
		var i32 lab;
		var pt:st:pl3:cas cas = stmt->data.cas;

		lab = map_find(&ctx->cases, cas);
		if(lab < 0)
			e:fmt("Internal error. Cannot find case label.");

		e:get(io:fmt(ctx->code, "  br label %%c%u\n", u32{lab}));
		e:get(io:fmt(ctx->code, "c%u:\n", u32{lab}));
	} break;

	case ev:pl3:stmt:dflt: {
		var i32 lab;

		lab = map_find(&ctx->cases, stmt);
		if(lab < 0)
			e:fmt("Internal error. Cannot find case label.");

		e:get(io:fmt(ctx->code, "  br label %%c%u\n", u32{lab}));
		e:get(io:fmt(ctx->code, "c%u:\n", u32{lab}));
	} break;

	case ev:pl3:stmt:brk:
	case ev:pl3:stmt:cont: {
		var pt:st:flow flow = env->flow;
		var u32 lab, i = stmt->data.depth;
		var cpt:char name = (stmt->tag == ev:pl3:stmt:brk) ? "break" : "continue";

		while(i-- > 1) {
			if(flow == null)
				e:fmt("Internal error. Invalid %s.", name);

			flow = flow->up;
		}

		if(flow == null)
			e:fmt("Internal error. Invalid %s.", name);

		lab = (stmt->tag == ev:pl3:stmt:brk) ? flow->brk : flow->cont;
		e:get(io:fmt(ctx->code, "  br label %%l%u\n", lab));
		e:get(io:fmt(ctx->code, "l%u:\n", ctx->lab++));
	} break;

	case ev:pl3:stmt:eret: {
		var pt:st:pl3:err err;
		var st:io:call val;

		err = pl3:type_get_err(ctx->sig->ret);
		if(err == null)
			e:fmt("Internal error. Invalid return type.");

		e:get(scope_emit(env->scope, ctx, env));

		val = e:get(ctx_expr(ctx, env, stmt->data.expr));
		if(pl3:type_is_void(err->suc)) {
			var st:io:call type;

			type = call_tyinfo(getref(st:tyinfo{ ctx, err->fail }));
			e:get(io:fmt(ctx->code, "\tret %C %C\n", type, val));
		}
		else {
			var st:io:call ret;

			ret = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = insertvalue %C undef, %C %C, 1\n", ret, call_type(&ctx->sig->ret), call_type(&err->fail), val));
			e:get(io:fmt(ctx->code, "\tret %C %C\n", call_type(&ctx->sig->ret), ret));
		}
	} break;

	case ev:pl3:stmt:onerr:
		scope_err(env->scope, stmt->data.stmt);
		break;

	default:
		fatal("FIXME stmt %u", stmt->tag);
	}
};

/**
 * Emit a normal expression.
 *   @ctx: The context.
 *   @env: The environment.
 *   @expr: The expression.
 *   &returns: The result.
 */
def e:str[st:io:call](pt:st:ctx ctx, pt:st:env env, pt:st:pl3:expr expr) ctx_expr = {
	var st:io:call type = call_type(&expr->type);

	switch(expr->tag) {
	case ev:pl3:expr:lit: {
		var st:io:call tmp = gen_tmp(ctx);
		var pt:st:pl3:lit lit = expr->data.lit;

		if(lit->tag == ev:pl3:lit:str) {
			var u32 i, sz, num;
			var pt:char str;
			var st:str:buf buf;

			num = ctx->str++;
			sz = lit->data.buf->sz;
			buf = str:buf_new(sz + 1);

			for(i = 0; i < sz; i++) {
				var char ch = lit->data.buf->arr[i];

				if(lex:is_alnum(i16{ch})) // FIXME, ch:is_alnum??
					str:buf_add_ch(&buf, ch);
				else {
					var u8 val;

					str:buf_add_ch(&buf, '\\');
					val = (ch >> 4);
					str:buf_add_ch(&buf, (val >= 10) ? ('a' + val - 10) : ('0' + val));
					val = (ch & 0xF);
					str:buf_add_ch(&buf, (val >= 10) ? ('a' + val - 10) : ('0' + val));
				}
			}
			
			str = str:buf_done(&buf);
			onerr mem:free(str);

			e:get(io:fmt(ctx->ext, "@s%u = internal local_unnamed_addr constant [%u x i8] c\"%s\", align 1\n", num, sz, str));
			e:get(io:fmt(ctx->code, "\t%C = getelementptr inbounds [%u x i8], [%u x i8]* @s%u, i64 0, i64 0\n", tmp, sz, sz, num));

			mem:free(str);
		}
		else {
			e:get(io:fmt(ctx->code, "\t%C = bitcast %C %C to %C\n", tmp, type, gen_lit(lit), type));
		}
	
		return tmp;
	} break;

	case ev:pl3:expr:ident: {
		var st:io:call mem, ret, tmp;
		var pt:st:pl3:ident ident = expr->data.ident;

		ret = gen_tmp(ctx);
		mem = e:get(ctx_left(ctx, env, expr));

		e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", ret, type, type, mem));

		return ret;
	} break;

	case ev:pl3:expr:op1: {
		var pt:st:pl3:op1 op1 = expr->data.op1;

		switch(op1->tag) {
		case ev:pl3:op1:deref: {
			var st:io:call in, tmp, ret;

			if(pl3:type_is_ptr(op1->in->type)) {
				in = e:get(ctx_expr(ctx, env, op1->in));

				tmp = gen_tmp(ctx);
				ret = gen_tmp(ctx);
				e:get(io:fmt(ctx->code, "\t%C = bitcast %C %C to %C*\n", tmp, call_type(&op1->in->type), in, call_type(&expr->type)));
				e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", ret, call_type(&expr->type), call_type(&expr->type), tmp));
			}
			else if(pl3:type_is_arr(op1->in->type)) {
				in = e:get(ctx_left(ctx, env, op1->in));

				//ret = gen_tmp(ctx);
				//e:get(io:fmt(ctx->code, "\t%C = getelementptr %C, %C* %C, i32 0, i32 0\n", ret, call_type(&op1->in->type), call_type(&op1->in->type), in));

				tmp = gen_tmp(ctx);
				ret = gen_tmp(ctx);
				e:get(io:fmt(ctx->code, "\t%C = getelementptr %C, %C* %C, i32 0, i32 0\n", tmp, call_type(&op1->in->type), call_type(&op1->in->type), in));
				e:get(io:fmt(ctx->code, "\t%C = bitcast %C* %C to i8*\n", ret, call_type(&op1->in->type.data.arr->type), tmp));
			}
			else
				e:fmt("Internal error. Invalid dereference.");

			return ret;
		} break;

		case ev:pl3:op1:addr: {
			var st:io:call val, ret;

			val = e:get(ctx_left(ctx, env, op1->in));

			ret = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = bitcast %C* %C to i8*\n", ret, call_type(&op1->in->type), val));

			return ret;
		} break;

		case ev:pl3:op1:preinc:
		case ev:pl3:op1:predec:
		case ev:pl3:op1:postinc:
		case ev:pl3:op1:postdec: {
			var bool inc, post;
			var st:io:call ptr, in, out, type;

			inc = ((op1->tag == ev:pl3:op1:postinc) || (op1->tag == ev:pl3:op1:preinc));
			post = ((op1->tag == ev:pl3:op1:postinc) || (op1->tag == ev:pl3:op1:postdec));

			ptr = e:get(ctx_left(ctx, env, op1->in));
			type = call_tyinfo(getref(st:tyinfo{ ctx, expr->type }));

			in = gen_tmp(ctx);
			out = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", in, type, type, ptr));

			if(pl3:type_is_int(expr->type))
				e:get(io:fmt(ctx->code, "\t%C = add %C %C, %d", out, type, in, i32{inc ? 1 : -1}));
			else if(pl3:type_is_fp(expr->type))
				fatal("FIXME stub float");
			else if(pl3:type_is_ptr(expr->type))
				e:get(io:fmt(ctx->code, "\t%C = getelementptr i8, i8* %C, i32 %d", out, in, i32{inc ? 1 : -1}));
			else
				e:fmt("%C: Invalid increment/decrement.", pl3:meta_call(&expr->meta));

			e:get(io:fmt(ctx->code, "\tstore %C %C, %C* %C\n", type, out, type, ptr));

			return post ? in : out;
		} break;

		case ev:pl3:op1:lnot: {
			var st:io:call in, ret;

			in = e:get(ctx_expr(ctx, env, op1->in));

			ret = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = xor i8 %C, 1\n", ret, in));

			return ret;
		} break;

		case ev:pl3:op1:pos:
			return e:get(ctx_expr(ctx, env, expr->data.op1->in));

		case ev:pl3:op1:neg: {
			var st:io:call res, in;
			var pt:st:pl3:op1 op1 = expr->data.op1;

			in = e:get(ctx_expr(ctx, env, expr->data.op1->in));
			res = gen_tmp(ctx);
			type = call_tyinfo(getref(st:tyinfo{ ctx, expr->type }));
			e:get(io:fmt(ctx->code, "\t%C = sub %C 0, %C\n", res, type, in));

			return res;
		} break;

		case ev:pl3:op1:not: {
			var st:io:call res, in;
			var pt:st:pl3:op1 op1 = expr->data.op1;

			in = e:get(ctx_expr(ctx, env, expr->data.op1->in));
			res = gen_tmp(ctx);
			type = call_tyinfo(getref(st:tyinfo{ ctx, expr->type }));
			e:get(io:fmt(ctx->code, "\t%C = xor %C -1, %C\n", res, type, in));

			return res;
		} break;

		default:
			fatal("FIXME %d %C", op1->tag, pl3:meta_call(&expr->meta));
		}
	} break;

	case ev:pl3:expr:op2: {
		var pt:st:pl3:op2 op2 = expr->data.op2;
		var st:io:call res, lhs, rhs;

		if(op2->tag == ev:pl3:op2:assign) {
			lhs = e:get(ctx_left(ctx, env, op2->lhs));
			rhs = e:get(ctx_expr(ctx, env, op2->rhs));
			res = rhs;
			e:get(io:fmt(ctx->code, "\tstore %C %C, %C* %C\n", type, rhs, type, lhs));
		}
		else if(pl3:op2_is_assign(op2->tag)) {
			var cpt:char op;
			var bool sign = pl3:type_is_signed(op2->lhs->type);
			var st:io:call ret, ptr, lhs, rhs, type;

			type = call_type(&expr->type);
			ptr = e:get(ctx_left(ctx, env, op2->lhs));
			rhs = e:get(ctx_expr(ctx, env, op2->rhs));

			lhs = gen_tmp(ctx);
			ret = gen_tmp(ctx);

			e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", lhs, type, type, ptr));

			if(pl3:type_is_ptr(op2->lhs->type) && pl3:type_is_int(op2->rhs->type)) {
				var u32 sz;
				var st:io:call off;
				var st:pl3:type sub = op2->lhs->type.data.ptr->type;

				if(op2->tag == ev:pl3:op2:subeq) {
					var st:io:call tmp;

					tmp = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = sub %C 0, %C\n", tmp, call_type(&op2->rhs->type), rhs));
					rhs = tmp;
				}

				sz = pl3:type_is_void(sub) ? 1 : pl3:type_size(sub, &pl3:arch_x64);
				off = gen_tmp(ctx);
				e:get(io:fmt(ctx->code, "\t%C = mul %C %C, %u\n", off, call_type(&op2->rhs->type), rhs, sz));
				e:get(io:fmt(ctx->code, "\t%C = getelementptr i8, i8* %C, %C %C\n", ret, lhs, call_type(&op2->rhs->type), off));
			}
			else if(pl3:type_is_fp(op2->lhs->type)) {
				switch(op2->tag) {
				case ev:pl3:op2:addeq: op = "fadd"; break;
				case ev:pl3:op2:subeq: op = "fsub"; break;
				case ev:pl3:op2:muleq: op = "fmul"; break;
				case ev:pl3:op2:diveq: op = "fdiv"; break;
				case ev:pl3:op2:remeq: op = "frem"; break;
				default: fatal("FIXME stub op2 fp");
				}

				e:get(io:fmt(ctx->code, "\t%C = %s %C %C, %C\n", ret, op, type, lhs, rhs));
			}
			else {
				switch(op2->tag) {
				case ev:pl3:op2:addeq: op = "add"; break;
				case ev:pl3:op2:subeq: op = "sub"; break;
				case ev:pl3:op2:muleq: op = "mul"; break;
				case ev:pl3:op2:diveq: op = (sign ? "sdiv": "udiv"); break;
				case ev:pl3:op2:remeq: op = (sign ? "srem": "urem"); break;
				case ev:pl3:op2:andeq: op = "and"; break;
				case ev:pl3:op2:oreq: op = "or"; break;
				case ev:pl3:op2:xoreq: op = "xor"; break;
				case ev:pl3:op2:shl: op = "shl"; break;
				case ev:pl3:op2:shr: op = (sign ? "ashr" : "lshr"); break;
				}

				e:get(io:fmt(ctx->code, "\t%C = %s %C %C, %C\n", ret, op, type, lhs, rhs));
			}

			e:get(io:fmt(ctx->code, "\tstore %C %C, %C* %C\n", type, ret, type, ptr));

			return ret;
		}
		else if(pl3:op2_is_arith(op2->tag)) {
			var cpt:char op;

			lhs = e:get(ctx_expr(ctx, env, op2->lhs));
			rhs = e:get(ctx_expr(ctx, env, op2->rhs));
			res = gen_tmp(ctx);

			if(pl3:type_is_ptr(op2->lhs->type) && pl3:type_is_int(op2->rhs->type)) {
				var u32 sz;
				var st:io:call off;
				var st:pl3:type sub = op2->lhs->type.data.ptr->type;

				if(op2->tag == ev:pl3:op2:sub) {
					var st:io:call tmp;

					tmp = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = sub %C 0, %C\n", tmp, call_type(&op2->rhs->type), rhs));
					rhs = tmp;
				}

				off = gen_tmp(ctx);
				sz = pl3:type_is_void(sub) ? 1 : pl3:type_size(sub, &pl3:arch_x64);
				e:get(io:fmt(ctx->code, "\t%C = mul %C %C, %u\n", off, call_type(&op2->rhs->type), rhs, sz));
				e:get(io:fmt(ctx->code, "\t%C = getelementptr i8, i8* %C, %C %C\n", res, lhs, call_type(&op2->rhs->type), off));
			}
			else if(pl3:type_is_fp(op2->lhs->type)) {
				switch(op2->tag) {
				case ev:pl3:op2:add: op = "fadd"; break;
				case ev:pl3:op2:sub: op = "fsub"; break;
				case ev:pl3:op2:mul: op = "fmul"; break;
				case ev:pl3:op2:div: op = "fdiv"; break;
				case ev:pl3:op2:rem: op = "frem"; break;
				default: fatal("FIXME stub op2 fp");
				}

				e:get(io:fmt(ctx->code, "\t%C = %s %C %C, %C\n", res, op, type, lhs, rhs));
			}
			else {
				var bool ptr, sign;

				ptr = pl3:type_is_ptr(op2->lhs->type);
				sign = pl3:type_is_signed(op2->lhs->type);

				if(ptr) {
					var st:io:call tmp;

					tmp = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = ptrtoint i8* %C to i64\n", tmp, lhs));
					lhs = tmp;

					tmp = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = ptrtoint i8* %C to i64\n", tmp, rhs));
					rhs = tmp;

					type = io:call_str("i64");
				}

				switch(op2->tag) {
				case ev:pl3:op2:add: op = "add"; break;
				case ev:pl3:op2:sub: op = "sub"; break;
				case ev:pl3:op2:mul: op = "mul"; break;
				case ev:pl3:op2:div: op = (sign ? "sdiv": "udiv"); break;
				case ev:pl3:op2:rem: op = (sign ? "srem": "urem"); break;
				case ev:pl3:op2:and: op = "and"; break;
				case ev:pl3:op2:or: op = "or"; break;
				case ev:pl3:op2:xor: op = "xor"; break;
				case ev:pl3:op2:shl: op = "shl"; break;
				case ev:pl3:op2:shr: op = (sign ? "ashr" : "lshr"); break;
				}

				if((op2->tag == ev:pl3:op2:shl) || (op2->tag == ev:pl3:op2:shr)) {
					if(pl3:type_size(op2->lhs->type, &pl3:arch_x64) < pl3:type_size(op2->rhs->type, &pl3:arch_x64)) {
						var st:io:call tmp;

						tmp = gen_tmp(ctx);
						e:get(io:fmt(ctx->code, "\t%C = trunc %C %C to %C\n", tmp, call_type(&op2->rhs->type), rhs, call_type(&op2->lhs->type)));
						rhs = tmp;
					}
					else if(pl3:type_size(op2->lhs->type, &pl3:arch_x64) > pl3:type_size(op2->rhs->type, &pl3:arch_x64)) {
						var st:io:call tmp;

						tmp = gen_tmp(ctx);
						e:get(io:fmt(ctx->code, "\t%C = sext %C %C to %C\n", tmp, call_type(&op2->rhs->type), rhs, call_type(&op2->lhs->type)));
						rhs = tmp;
					}
				}

				e:get(io:fmt(ctx->code, "\t%C = %s %C %C, %C\n", res, op, type, lhs, rhs));

				if(ptr) {
					var st:io:call tmp;

					tmp = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = inttoptr i64 %C to i8*\n", tmp, res));
					res = tmp;
				}
			}
		}
		else if(pl3:op2_is_cmp(op2->tag)) {
			var cpt:char op;
			var char pre;
			var st:io:call tmp, type;

			lhs = e:get(ctx_expr(ctx, env, op2->lhs));
			rhs = e:get(ctx_expr(ctx, env, op2->rhs));
			res = gen_tmp(ctx);

			if(pl3:type_is_fp(op2->lhs->type)) {
				pre = 'f';

				switch(op2->tag) {
				case ev:pl3:op2:eq: op = "oeq"; break;
				case ev:pl3:op2:ne: op = "one"; break;
				case ev:pl3:op2:lt: op = "olt"; break;
				case ev:pl3:op2:lte: op = "ole"; break;
				case ev:pl3:op2:gt: op = "ogt"; break;
				case ev:pl3:op2:gte: op = "oge"; break;
				default: unreachable();
				}
			}
			else {
				var bool sign = pl3:type_is_signed(op2->lhs->type);

				pre = 'i';

				switch(op2->tag) {
				case ev:pl3:op2:eq: op = "eq"; break;
				case ev:pl3:op2:ne: op = "ne"; break;
				case ev:pl3:op2:lt: op = (sign ? "slt" : "ult"); break;
				case ev:pl3:op2:lte: op = (sign ? "sle" : "ule"); break;
				case ev:pl3:op2:gt: op = (sign ? "sgt" : "ugt"); break;
				case ev:pl3:op2:gte: op = (sign ? "sge" : "uge"); break;
				default: unreachable();
				}
			}

			type = call_tyinfo(getref(st:tyinfo{ ctx, op2->lhs->type }));
			tmp = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = %ccmp %s %C %C, %C\n", tmp, pre, op, type, lhs, rhs));
			e:get(io:fmt(ctx->code, "\t%C = zext i1 %C to i8\n", res, tmp));
		}
		else if((op2->tag == ev:pl3:op2:land) || (op2->tag == ev:pl3:op2:lor)) {
			var u32 enter, before, mid, after;
			var st:io:call tmp, lhs, rhs, ret;

			enter = ctx->lab++;
			before = ctx->lab++;
			mid = ctx->lab++;
			after = ctx->lab++;

			tmp = e:get(ctx_expr(ctx, env, op2->lhs));

			e:get(io:fmt(ctx->code, "  br label %%l%u\n", enter));
			e:get(io:fmt(ctx->code, "l%u:\n", enter));

			lhs = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = bitcast i8 %C to i8\n", lhs, tmp));
			
			if(op2->tag == ev:pl3:op2:land)
				e:get(io:fmt(ctx->code, "  br i1 %C, label %%l%u, label %%l%u\n", e:get(mk_bool(ctx, lhs)), before, after));
			else
				e:get(io:fmt(ctx->code, "  br i1 %C, label %%l%u, label %%l%u\n", e:get(mk_bool(ctx, lhs)), after, before));

			e:get(io:fmt(ctx->code, "l%u:\n", before));
			tmp = e:get(ctx_expr(ctx, env, op2->rhs));
			e:get(io:fmt(ctx->code, "  br label %%l%u\n", mid));
			e:get(io:fmt(ctx->code, "l%u:\n", mid));

			rhs = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "  %C = bitcast i8 %C to i8\n", rhs, tmp));

			e:get(io:fmt(ctx->code, "  br label %%l%u\n", after));
			e:get(io:fmt(ctx->code, "l%u:\n", after));

			ret = gen_tmp(ctx);
			if(op2->tag == ev:pl3:op2:land)
				e:get(io:fmt(ctx->code, "  %C = phi i8 [ 0, %%l%u ], [ %C, %%l%u ]\n", ret, enter, rhs, mid));
			else
				e:get(io:fmt(ctx->code, "  %C = phi i8 [ 1, %%l%u ], [ %C, %%l%u ]\n", ret, enter, rhs, mid));

			return ret;
		}
		else
			fatal("FIXME stub %d", op2->tag);

		return res;
	} break;

	case ev:pl3:expr:index: {
		var pt:st:pl3:arr arr;
		var st:io:call base, off;
		var pt:st:pl3:index index = expr->data.index;

		base = e:get(ctx_expr(ctx, env, index->base));
		off = e:get(ctx_expr(ctx, env, index->off));

		if(pl3:type_is_ptr(index->base->type)) {
			var st:io:call type, ptr, cast, ret;

			type = call_tyinfo(getref(st:tyinfo{ ctx, index->base->type.data.ptr->type }));
			ptr = gen_tmp(ctx);
			cast = gen_tmp(ctx);
			ret = gen_tmp(ctx);

			e:get(io:fmt(ctx->code, "\t%C = bitcast %C %C to %C*\n", ptr, call_type(&index->base->type), base, type));
			e:get(io:fmt(ctx->code, "\t%C = getelementptr %C, %C* %C, %C %C\n", cast, type, type, ptr, call_type(&index->off->type), off));
			e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", ret, type, type, cast));

			return ret;
		}
		else if((arr = pl3:type_get_arr(index->base->type)) != null) {
			var st:io:call tmp, ptr, ret, type;

			tmp = gen_tmp(ctx);
			ptr = gen_tmp(ctx);
			ret = gen_tmp(ctx);
			type = call_type(&index->base->type);

			e:get(io:fmt(ctx->vars, "\t%C = alloca %C\n", tmp, type));
			e:get(io:fmt(ctx->code, "\tstore %C %C, %C* %C\n", type, base, type, tmp));
			e:get(io:fmt(ctx->code, "\t%C = getelementptr %C, %C* %C, i32 0, %C %C\n", ptr, type, type, tmp, call_type(&index->off->type), off));
			e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", ret, call_type(&expr->type), call_type(&expr->type), ptr));

			return ret;
		}
		else
			e:fmt("%C: Internal error. Invalid index operation.", pl3:meta_call(&expr->meta));
	} break;

	case ev:pl3:expr:comp: {
		var pt:st:pl3:agg agg;
		var pt:st:pl3:arr arr;
		var pt:st:pl3:comp comp = expr->data.comp;
		var pt:st:pl3:list list = comp->list;
		var en:pl3:type tag;

		agg = pl3:type_get_agg(comp->type, &tag);
		if(agg != null) {
			return e:get(emit_list(ctx, env, tag, agg, list));
		}
		else if((arr = pl3:type_get_arr(comp->type)) != null)
			return e:get(emit_arr(ctx, env, tag, arr, list));
		else {
			var st:io:call val;
			var pt:st:pl3:expr src;

			assert((list->init != null) && (list->init->next == null) && (list->init->tag == ev:pl3:init:expr));

			src = list->init->data.expr;
			val = e:get(ctx_expr(ctx, env, src));

			if(pl3:type_is_int(src->type) && pl3:type_is_int(comp->type)) {
				if(pl3:type_size(src->type, &pl3:arch_x64) > pl3:type_size(comp->type, &pl3:arch_x64)) {
					var st:io:call ret;

					ret = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = trunc %C %C to %C\n", ret, call_type(&src->type), val, call_type(&comp->type)));

					return ret;
				}
				else if(pl3:type_size(src->type, &pl3:arch_x64) < pl3:type_size(comp->type, &pl3:arch_x64)) {
					var st:io:call ret;

					ret = gen_tmp(ctx);
					// TODO char type implied
					e:get(io:fmt(ctx->code, "\t%C = %cext %C %C to %C\n", ret, char{pl3:type_is_signed(comp->type) ? 's' : 'z'}, call_type(&src->type), val, call_type(&comp->type)));

					return ret;
				}
				else
					return val;
			}
			else if(pl3:type_is_ptr(src->type) && pl3:type_is_int(comp->type)) {
				var st:io:call ret, src_type, dst_type;

				ret = gen_tmp(ctx);
				src_type = call_tyinfo(getref(st:tyinfo{ ctx, src->type }));
				dst_type = call_tyinfo(getref(st:tyinfo{ ctx, comp->type }));
				e:get(io:fmt(ctx->code, "\t%C = ptrtoint %C %C to %C\n", ret, src_type, val, dst_type));

				return ret;
			}
			else if(pl3:type_is_int(src->type) && pl3:type_is_ptr(comp->type)) {
				var st:io:call ret, src_type, dst_type;

				ret = gen_tmp(ctx);
				src_type = call_tyinfo(getref(st:tyinfo{ ctx, src->type }));
				dst_type = call_tyinfo(getref(st:tyinfo{ ctx, comp->type }));
				e:get(io:fmt(ctx->code, "\t%C = inttoptr %C %C to %C\n", ret, src_type, val, dst_type));

				return ret;
			}
			else if(pl3:type_is_ptr(src->type) && pl3:type_is_ptr(comp->type))
				return val;
			else if(pl3:type_is_int(src->type) && pl3:type_is_fp(comp->type)) {
				var st:io:call ret, src_type, dst_type;

				ret = gen_tmp(ctx);
				src_type = call_tyinfo(getref(st:tyinfo{ ctx, src->type }));
				dst_type = call_tyinfo(getref(st:tyinfo{ ctx, comp->type }));
				e:get(io:fmt(ctx->code, "\t%C = %citofp %C %C to %C\n", ret, pl3:type_is_signed(src->type) ? 's' : 'u', src_type, val, dst_type));

				return ret;
			}
			else if(pl3:type_is_fp(src->type) && pl3:type_is_int(comp->type)) {
				var st:io:call ret, src_type, dst_type;

				ret = gen_tmp(ctx);
				src_type = call_tyinfo(getref(st:tyinfo{ ctx, src->type }));
				dst_type = call_tyinfo(getref(st:tyinfo{ ctx, comp->type }));
				e:get(io:fmt(ctx->code, "\t%C = fpto%ci %C %C to %C\n", ret, pl3:type_is_signed(comp->type) ? 's' : 'u', src_type, val, dst_type));

				return ret;
			}
			else if(pl3:type_is_fp(src->type) && pl3:type_is_fp(comp->type)) {
				var cpt:char name;
				var st:io:call ret, src_type, dst_type;

				if(pl3:type_size(src->type, &pl3:arch_x64) > pl3:type_size(comp->type, &pl3:arch_x64))
					name = "fptrunc";
				else
					name = "fpext";

				ret = gen_tmp(ctx);
				src_type = call_tyinfo(getref(st:tyinfo{ ctx, src->type }));
				dst_type = call_tyinfo(getref(st:tyinfo{ ctx, comp->type }));
				e:get(io:fmt(ctx->code, "\t%C = %s %C %C to %C\n", ret, name, src_type, val, dst_type));

				return ret;
				
			}
			else if(pl3:type_is_ptr(src->type) && pl3:type_is_ptr(comp->type))
				fatal("FIXME stub cast");
			else
				fatal("FIXME stub cast");
		}
        } break;

	case ev:pl3:expr:call: {
		var u32 i;
		var st:io:call func, ret;
		var pt:st:pl3:arg arg;
		var pt:st:pl3:sig sig;
		var pt:st:arg list;
		var pt:st:pl3:call call = expr->data.call;

		if(call->deref) {
			var pt:st:pl3:ptr ptr;
			var st:io:call tmp;

			ptr = pl3:type_get_ptr(call->func->type);
			if(ptr == null)
				e:fmt("%C: Cannot dereference non-pointer type.", pl3:meta_call(&expr->meta));

			sig = pl3:type_get_sig(ptr->type);
			if(sig == null)
				e:fmt("%C: Cannot call non-function type.", pl3:meta_call(&expr->meta));

			tmp = e:get(ctx_expr(ctx, env, call->func));

			func = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = bitcast i8* %C to %C*\n", func, tmp, call_type(&ptr->type)));
		}
		else {
			sig = pl3:type_get_sig(call->func->type);
			if(sig == null)
				e:fmt("%C: Cannot call non-function type.", pl3:meta_call(&expr->meta));

			func = e:get(ctx_left(ctx, env, call->func));
		}

		list = mem:alloc((pl3:call_cnt(call) + 1) * sizeof(st:arg));
		onerr mem:free(list);

		// FIXME: sloppy
		var pt:st:pl3:param param = sig->param;
		i = 0;
		for(arg = call->arg; arg != null; arg = arg->next) {
			list[i++] = st:arg{ &arg->expr->type, e:get(ctx_expr(ctx, env, arg->expr)) };
			param = ((param != null) ? param->next : null);
		}

		list[i] = st:arg{ null, io:call_null };

		if(pl3:type_is_void(sig->ret)) {
			ret = io:call_null;
			e:get(io:fmt(ctx->code, "\tcall %C %C(%C)\n", call_sig(sig), func, call_args(list)));
		}
		else {
			ret = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = call %C %C(%C)\n", ret, call_sig(sig), func, call_args(list)));
		}
/*
		if(!el_type_is_void(func->ret)) {
			*out = env->reg++;
			bprintf(&env->code, "  %%r%u = call %t %%r%u(", *out, func->var ? el_type_func(func) : func->ret, ptr);
		}
		else if(func->var)
			bprintf(&env->code, "  call %t %%r%u(", el_type_func(func), ptr);
		else
			bprintf(&env->code, "  call void %%r%u(", ptr);

		for(i = 0, arg = call->arg; arg != NULL; i++, arg = arg->next)
			bprintf(&env->code, "%s%t %%r%u", (i > 0) ? ", " : "", arg->expr->type, lst[i]);
			*/

		mem:free(list);

		return ret;
	} break;

	case ev:pl3:expr:elem: {
		var pt:st:pl3:elem elem = expr->data.elem;
		var st:pl3:type type = elem->expr->type;

		if(pl3:type_get_err(type) != null) {
			var st:io:call ret, base;
			var pt:st:pl3:err err = pl3:type_get_err(type);

			base = e:get(ctx_expr(ctx, env, elem->expr));

			if(str:equal(elem->id, "err")) {
				if(!pl3:type_is_void(err->suc)) {
					ret = gen_tmp(ctx);
					e:get(io:fmt(ctx->code, "\t%C = extractvalue %C %C, 1\n", ret, call_type(&type), base));
				}
				else
					ret = base;
			}
			else if(str:equal(elem->id, "val")) {
				fatal("stub elem val");
			}
			else
				e:fmt("Internal error. Invalid member access on error type.");

			return ret;
		}
		else {
			var en:pl3:tydecl tag;
			var st:io:call ret, tmp, tyinfo, base;
			var pt:st:pl3:elem elem = expr->data.elem;
			var st:pl3:type type = elem->expr->type;
		
			base = e:get(ctx_expr(ctx, env, elem->expr));

			if(elem->deref) {
				var pt:st:pl3:ptr ptr = pl3:type_get_ptr(type);

				if(ptr == null)
					fatal("Invalid state. Attempted to dereference non-pointer type.");
			
				type = ptr->type;
				tyinfo = call_tyinfo(getref(st:tyinfo{ ctx, type }));

				tmp = gen_tmp(ctx);
				e:get(io:fmt(ctx->code, "\t%C = bitcast i8* %C to %C*\n", tmp, base, call_type(&type)));

				ret = gen_tmp(ctx);
				e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", ret, call_type(&type), call_type(&type), tmp));
				base = ret;
			}

			if(pl3:type_get_agg(type, &tag) == null)
				e:fmt("Internal error. Invalid element access.");

			ret = gen_tmp(ctx);

			if(tag == ev:pl3:tydecl:struct) {
				tyinfo = call_tyinfo(getref(st:tyinfo{ ctx, type }));
				e:get(io:fmt(ctx->code, "\t%C = extractvalue %C %C, %u\n", ret, tyinfo, base, elem->idx));
			}
			else if(tag == ev:pl3:tydecl:union) {
				var st:io:call tmp, cast;
				var u32 sz = 8 * pl3:type_size(type, &pl3:arch_x64);

				tmp = gen_tmp(ctx);
				cast = gen_tmp(ctx);

				e:get(io:fmt(ctx->vars, "\t%C = alloca i%u\n", tmp, sz));
				e:get(io:fmt(ctx->code, "\tstore i%u %C, i%u* %C\n", sz, base, sz, tmp));
				e:get(io:fmt(ctx->code, "\t%C = bitcast i%u* %C to %C*\n", cast, sz, tmp, call_type(&expr->type)));
				e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", ret, call_type(&expr->type), call_type(&expr->type), cast));
			}
			else
				e:fmt("Internal error. Invalid element access.");

			return ret;
		}
	} break;

	case ev:pl3:expr:eget: {
		var u32 onsuc, onfail;
		var st:io:call type, fty, val, suc, fail, cond, pack;
		var pt:st:pl3:err err;

		err = pl3:type_get_err(expr->data.expr->type);
		if(err == null)
			e:fmt("Call to `e:get` requires error value.");

		val = e:get(ctx_expr(ctx, env, expr->data.expr));
		type = call_tyinfo(getref(st:tyinfo{ ctx, expr->data.expr->type }));
		fty = call_tyinfo(getref(st:tyinfo{ ctx, err->fail }));
		fail = gen_tmp(ctx);

		if(!pl3:type_is_void(err->suc)) {
			fail = gen_tmp(ctx);
			suc = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = extractvalue %C %C, 0\n", suc, type, val));
			e:get(io:fmt(ctx->code, "\t%C = extractvalue %C %C, 1\n", fail, type, val));
		}
		else {
			suc = io:call_str("undef");
			fail = val;
		}

		onsuc = ctx->lab++;
		onfail = ctx->lab++;

		cond = gen_tmp(ctx);
		e:get(io:fmt(ctx->code, "\t%C = icmp eq %C %C, %s", cond, fty, fail, pl3:type_is_ptr(err->fail) ? "null" : "0"));
		e:get(io:fmt(ctx->code, "\tbr i1 %C, label %%l%u, label %%l%u\n", cond, onsuc, onfail));
		e:get(io:fmt(ctx->code, "l%u:\n", onfail));

		e:get(scope_emit(env->scope, ctx, env));

		err = pl3:type_get_err(ctx->sig->ret);
		if(err == null)
			e:fmt("Call to `e:get` must be in a function returning an error type.");

		if(!pl3:type_is_void(err->suc)) {
			pack = gen_tmp(ctx);
			type = call_tyinfo(getref(st:tyinfo{ ctx, ctx->sig->ret }));
			var st:io:call ety;
			// FIXME so ugly
			ety = call_tyinfo(getref(st:tyinfo{ ctx, err->fail }));
			type = call_tyinfo(getref(st:tyinfo{ ctx, ctx->sig->ret }));
			e:get(io:fmt(ctx->code, "\t%C = insertvalue %C undef, %C %C, 1\n", pack, type, ety, fail));
			e:get(io:fmt(ctx->code, "\tret %C %C\n", type, pack));
		}
		else
			e:get(io:fmt(ctx->code, "\tret %C %C\n", call_type(&ctx->sig->ret), fail));

		e:get(io:fmt(ctx->code, "l%u:\n", onsuc));

		return suc;
	} break;

	case ev:pl3:expr:ereq: {
		// TODO fix this, and the damn thing above it
		var u32 onsuc, onfail;
		var st:io:call type, fty, val, suc, fail, cond, pack;
		var pt:st:pl3:err err;

		err = pl3:type_get_err(expr->data.expr->type);
		if(err == null)
			e:fmt("Call to `e:get` requires error value.");

		val = e:get(ctx_expr(ctx, env, expr->data.expr));
		type = call_tyinfo(getref(st:tyinfo{ ctx, expr->data.expr->type }));
		fty = call_tyinfo(getref(st:tyinfo{ ctx, err->fail }));
		fail = gen_tmp(ctx);

		if(!pl3:type_is_void(err->suc)) {
			fail = gen_tmp(ctx);
			suc = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = extractvalue %C %C, 0\n", suc, type, val));
			e:get(io:fmt(ctx->code, "\t%C = extractvalue %C %C, 1\n", fail, type, val));
		}
		else {
			suc = io:call_str("undef");
			fail = val;
		}

		onsuc = ctx->lab++;
		onfail = ctx->lab++;

		cond = gen_tmp(ctx);
		e:get(io:fmt(ctx->code, "\t%C = icmp eq %C %C, %s", cond, fty, fail, pl3:type_is_ptr(err->fail) ? "null" : "0"));
		e:get(io:fmt(ctx->code, "\tbr i1 %C, label %%l%u, label %%l%u\n", cond, onsuc, onfail));
		e:get(io:fmt(ctx->code, "l%u:\n", onfail));

		//var u32 dbg = map_get(&ctx->dbgs, expr);
		//FIXME need to check type, pass it properly to fatal with
		//format strings
		e:get(io:fmt(ctx->code, "\tcall void(i8*, ...) @fatal(%C %C)\n", fty, fail));
		//e:get(io:fmt(ctx->code, "\tcall void(i8*, ...) @fatal(%t %%r%u), !dbg !%u\n", etype, err, dbg));
		//e:get(io:fmt(ctx->ext, "!%u = distinct !DILocation(line: %u, column: %u, scope: !%u)\n", dbg, expr->tag->line, expr->tag->col, env->prog));
		e:get(io:fmt(ctx->code, "\tunreachable\n"));

		e:get(io:fmt(ctx->code, "l%u:\n", onsuc));

		return suc;
	} break;

	case ev:pl3:expr:tern: {
		var st:io:call eval, ret, lhs, rhs;
		var u32 ontrue, onfalse, after, left, right;
		var pt:st:pl3:tern tern = expr->data.tern;

		after = ctx->lab++;
		ontrue = ctx->lab++;
		onfalse = ctx->lab++;

		eval = e:get(ctx_expr(ctx, env, tern->cond));	

		e:get(io:fmt(ctx->code, "\tbr i1 %C, label %%l%u, label %%l%u\n", e:get(mk_bool(ctx, eval)), ontrue, onfalse));

		left = ctx->lab++;
		e:get(io:fmt(ctx->code, "l%u:\n", ontrue));
		lhs = e:get(ctx_expr(ctx, env, tern->ontrue));
		e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", left));
		e:get(io:fmt(ctx->code, "l%u:\n", left));
		e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", after));

		right = ctx->lab++;
		e:get(io:fmt(ctx->code, "l%u:\n", onfalse));
		rhs = e:get(ctx_expr(ctx, env, tern->onfalse));
		e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", right));
		e:get(io:fmt(ctx->code, "l%u:\n", right));
		e:get(io:fmt(ctx->code, "\tbr label %%l%u\n", after));

		e:get(io:fmt(ctx->code, "l%u:\n", after));

		ret = gen_tmp(ctx);
		e:get(io:fmt(ctx->code, "\t%C = phi %C [ %C, %%l%u ], [ %C, %%l%u ]\n", ret, call_type(&expr->type), lhs, left, rhs, right));

		return ret;
	} break;

	case ev:pl3:expr:size: {
		var st:io:call ret, type;
		var pt:st:pl3:size size = expr->data.size;

		ret = gen_tmp(ctx);
		type = call_type(&expr->type);
		//TODO: check out of range size
		e:get(io:fmt(ctx->code, "\t%C = bitcast %C %d to %C\n", ret, type, pl3:type_size(size->type, &pl3:arch_x64), type));

		return ret;
	} break;

	case ev:pl3:expr:arrlen: {
		var st:io:call ret, type;
		var pt:st:pl3:arrlen alen = expr->data.len;

		ret = gen_tmp(ctx);
		type = call_type(&expr->type);
		//TODO: check out of range size
		e:get(io:fmt(ctx->code, "\t%C = bitcast %C %d to %C\n", ret, type, alen->val, type));

		return ret;
	} break;

	case ev:pl3:expr:offset: {
		var pt:st:pl3:agg agg;
		var st:io:call ret, type;
		var pt:st:pl3:offset offset = expr->data.offset;

		agg = pl3:type_get_struct(offset->type);
		if(agg == null)
			e:fmt("%C: Cannot retrieve offset from non-structure type '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&offset->type));


		ret = gen_tmp(ctx);
		type = call_type(&expr->type);
		//TODO: check out of range size
		e:get(io:fmt(ctx->code, "\t%C = bitcast %C %d to %C\n", ret, type, offset->val, type));

		return ret;
	} break;

	case ev:pl3:expr:parent: {
		var st:io:call ret, in;
		var pt:st:pl3:parent parent = expr->data.parent;

		in = e:get(ctx_expr(ctx, env, parent->expr));
		ret = gen_tmp(ctx);
		e:get(io:fmt(ctx->code, "\t%C = getelementptr i8, i8* %C, i32 -%u\n", ret, in, parent->off));

		return ret;
	} break;

	case ev:pl3:expr:enref:
		return ctx_expr(ctx, env, expr->data.enref->val->expr);

	case ev:pl3:expr:func: {
		var pt:st:pl3:func func = expr->data.func;

		*ctx->idefer = mem:make(st:defer{ null, func, null });
		ctx->idefer = &(*ctx->idefer)->next;

		return ref_uniq(ctx, func);
	} break;

	case ev:pl3:expr:vinit: {
		var st:io:call tmp, ptr, ret;

		tmp = gen_tmp(ctx);
		ptr = gen_tmp(ctx);
		ret = gen_tmp(ctx);

		e:get(io:fmt(ctx->vars, "\t%C = alloca %%\"$args\"\n", tmp));
		e:get(io:fmt(ctx->vars, "\t%C = bitcast %%\"$args\"* %C to i8*\n", ptr, tmp));
		e:get(io:fmt(ctx->code, "\tcall void @llvm.va_start(i8* %C)\n", ptr));
		e:get(io:fmt(ctx->code, "\t%C = load %%\"$args\", %%\"$args\"* %C\n", ret, tmp));

		return ret;
	} break;

	case ev:pl3:expr:vget: {
		var st:io:call args, ret;
		var pt:st:pl3:vget get = expr->data.vget;

		args = e:get(ctx_expr(ctx, env, get->expr));
		ret = gen_tmp(ctx);

		//if(pl3:type_get_agg(get->type, null) != null) {
			var u32 sz = 8 * pl3:type_size(get->type, &pl3:arch_x64);
			var st:io:call tmp, val, ptr, type;

			tmp = gen_tmp(ctx);
			val = gen_tmp(ctx);
			ptr = gen_tmp(ctx);
			type = call_type(&get->type);

			e:get(io:fmt(ctx->vars, "\t%C = alloca i%u\n", tmp, sz));
			e:get(io:fmt(ctx->code, "\t%C = bitcast i%u* %C to i8*\n", val, sz, tmp));
			e:get(io:fmt(ctx->code, "\tcall void @_getarg(i8* %C, i32 %u, i8* %C)\n", args, sz, val));
			//e:get(io:fmt(ctx->code, "\t%C = va_arg i8* %C, i%u\n", val, args, sz));
			//e:get(io:fmt(ctx->code, "\tstore i%u %C, i%u* %C\n", sz, val, sz, tmp));
			e:get(io:fmt(ctx->code, "\t%C = bitcast i%u* %C to %C*\n", ptr, sz, tmp, type));
			e:get(io:fmt(ctx->code, "\t%C = load %C, %C* %C\n", ret, type, type, ptr));
		//}
		//else
			//e:get(io:fmt(ctx->code, "\t%C = va_arg i8* %C, %C\n", ret, args, call_type(&get->type)));

		return ret;
	} break;

	case ev:pl3:expr:getref: {
		var st:io:call val, tmp, ret, type;

		tmp = gen_tmp(ctx);
		ret = gen_tmp(ctx);
		type = call_type(&expr->data.expr->type);

		val = e:get(ctx_expr(ctx, env, expr->data.expr));
		e:get(io:fmt(ctx->vars, "\t%C = alloca %C\n", tmp, type));
		e:get(io:fmt(ctx->code, "\tstore %C %C, %C* %C\n", type, val, type, tmp));
		e:get(io:fmt(ctx->code, "\t%C = bitcast %C* %C to i8*\n", ret, type, tmp));

		return ret;
	} break;
	
	default:
		fatal("FIXME expr %u", expr->tag);
	}
};

/**
 * Emit a left-hand expression.
 *   @ctx: The context.
 *   @env: The environment.
 *   @expr: The expression.
 *   &returns: The result.
 */
def e:str[st:io:call](pt:st:ctx ctx, pt:st:env env, pt:st:pl3:expr expr) ctx_left = {
	switch(expr->tag) {
	case ev:pl3:expr:ident: {
		var i32 id;
		var cpt:void ptr;
		var cpt:char name;
		var pt:st:pl3:ident ident = expr->data.ident;

		switch(ident->tag) {
		case ev:pl3:ident:unk:
			e:fmt("Cannot emit unresolved symbol '%s'.", ident->str);

		case ev:pl3:ident:param:
			ptr = ident->data.param;
			name = ident->data.param->id;
			break;

		case ev:pl3:ident:link: {
			var pt:st:pl3:bind bind = ident->data.link.bind;

			if(pl3:type_is_sig(expr->type)) {
				if(bind->expr == null)
					return ref_bind(ctx, bind);
					//FIXME not this? e:fmt("Internal error. Cannot have uninitialized function.");
				else if(bind->expr->tag != ev:pl3:expr:func)
					e:fmt("Internal error. Invalid function variable.");

				return ref_bind(ctx, bind);
			}

			ptr = bind;
			name = bind->id;
		} break;

		case ev:pl3:ident:builtin:
			if(str:equal(ident->str, "bi:syscall"))
				return io:call_str("@$syscall");
			else
				e:fmt("Unsupported builtin '%s'.", ident->str);
		}

		id = map_find(env->map, ptr);
		if(id >= 0)
			return call_local(u32{id});
		else
			return ref_bind(ctx, ptr);
	} break;

	case ev:pl3:expr:op1: {
		var pt:st:pl3:op1 op1 = expr->data.op1;

		switch(op1->tag) {
		case ev:pl3:op1:deref: {
			var st:io:call val, ret;

			ret = gen_tmp(ctx);
			val = e:get(ctx_expr(ctx, env, op1->in));
			e:get(io:fmt(ctx->code, "\t%C = bitcast i8* %C to %C*\n", ret, val, call_type(&expr->type)));

			return ret;
		} break;

		default:
			fatal("FIXME op1 %u %C", op1->tag, pl3:meta_call(&expr->meta));
		}
	} break;

	case ev:pl3:expr:index: {
		var pt:st:pl3:arr arr;
		var st:io:call base, off;
		var pt:st:pl3:index index = expr->data.index;

		off = e:get(ctx_expr(ctx, env, index->off));

		if(pl3:type_is_ptr(index->base->type)) {
			var st:io:call type, ptr, cast;

			base = e:get(ctx_expr(ctx, env, index->base));

			type = call_type(&index->base->type.data.ptr->type);
			ptr = gen_tmp(ctx);
			cast = gen_tmp(ctx);

			e:get(io:fmt(ctx->code, "\t%C = bitcast i8* %C to %C*\n", ptr, base, type));
			e:get(io:fmt(ctx->code, "\t%C = getelementptr %C, %C* %C, %C %C\n", cast, type, type, ptr, call_type(&index->off->type), off));

			return cast;
		}
		else if((arr = pl3:type_get_arr(index->base->type)) != null) {
			var st:io:call ret, type;

			base = e:get(ctx_left(ctx, env, index->base));
		
			ret = gen_tmp(ctx);
			type = call_type(&index->base->type);
			e:get(io:fmt(ctx->code, "\t%C = getelementptr %C, %C* %C, i64 0, %C %C\n", ret, type, type, base, call_type(&index->off->type), off));

			return ret;
		}
		else
			e:fmt("%C: Invalid index operation.", pl3:meta_call(&expr->meta));
	} break;

	case ev:pl3:expr:elem: {
		var en:pl3:tydecl tag;
		var st:io:call ret, base;
		var pt:st:pl3:elem elem = expr->data.elem;
		var st:pl3:type type = elem->expr->type;

		if(elem->deref) {
			var pt:st:pl3:ptr ptr;
			var st:io:call tmp;

			ptr = pl3:type_get_ptr(type);
			if(ptr == null)
				e:fmt("Internal error. Expected pointer type.");

			type = ptr->type;
			tmp = e:get(ctx_expr(ctx, env, elem->expr));

			base = gen_tmp(ctx);
			e:get(io:fmt(ctx->code, "\t%C = bitcast i8* %C to %C*\n", base, tmp, call_type(&type)));
		}
		else
			base = e:get(ctx_left(ctx, env, elem->expr));

		if(pl3:type_get_agg(type, &tag) == null)
			e:fmt("Internal error. Invalid element access.");

		ret = gen_tmp(ctx);

		if(tag == ev:pl3:tydecl:struct)
			e:get(io:fmt(ctx->code, "\t%C = getelementptr %C, %C* %C, i32 0, i32 %u\n", ret, call_type(&type), call_type(&type), base, elem->idx));
		else if(tag == ev:pl3:tydecl:union)
			e:get(io:fmt(ctx->code, "\t%C = bitcast i%u* %C to %C*\n", ret, 8 * pl3:type_size(type, &pl3:arch_x64), base, call_type(&expr->type)));
		else
			e:fmt("Internal error. Invalid element access.");

		return ret;
	} break;

	default:
		fatal("FIXME expr %u %C", expr->tag, pl3:meta_call(&expr->meta));
	}
};

def e:str[st:io:call](pt:st:ctx ctx, pt:st:env env, en:pl3:type tag, pt:st:pl3:agg agg, pt:st:pl3:list list) emit_list = {
	switch(tag) {
	case ev:pl3:tydecl:struct:
		return e:get(emit_struct(ctx, env, agg, list));

	case ev:pl3:tydecl:union:
		return e:get(emit_union(ctx, env, agg, list));

	default:
		e:fmt("%C: Internal error. Invalid compound literal.", pl3:meta_call(&list->meta));
	}
};

def e:str[st:io:call](pt:st:ctx ctx, pt:st:env env, pt:st:pl3:init init) emit_init = {
	switch(init->tag) {
	case ev:pl3:init:expr:
		return e:get(ctx_expr(ctx, env, init->data.expr));

	case ev:pl3:init:nest: {
		var en:pl3:type tag;
		var pt:st:pl3:agg agg;

		if((agg = pl3:type_get_agg(init->type, &tag)) == null)
			e:fmt("Internal error. Invalid structure type.");

		return e:get(emit_list(ctx, env, tag, agg, init->data.list));
	} break;
	}

	unreachable();
};

/**
 * Emit a structure value.
 *   @ctx: The context.
 *   @env: The environment.
 *   @agg: The aggregate.
 *   @list; The initializer list.
 *   &returns: The result.
 */
def e:str[st:io:call](pt:st:ctx ctx, pt:st:env env, pt:st:pl3:agg agg, pt:st:pl3:list list) emit_struct = {
	var st:io:call type, val, elem, tmp;
	var pt:st:pl3:init init;

	val = io:call_str("undef");
	type = call_struct(agg);

	for(init = list->init; init != null; init = init->next) {
		elem = e:get(emit_init(ctx, env, init));

		tmp = gen_tmp(ctx);
		e:get(io:fmt(ctx->code, "\t%C = insertvalue %C %C, %C %C, %d\n", tmp, type, val, call_type(&init->type), elem, init->idx));
		val = tmp;
	}

	return val;
};

/**
 * Emit a union value.
 *   @ctx: The context.
 *   @env: The environment.
 *   @agg: The aggregate.
 *   @list; The initializer list.
 *   &returns: The result.
 */
def e:str[st:io:call](pt:st:ctx ctx, pt:st:env env, pt:st:pl3:agg agg, pt:st:pl3:list list) emit_union = {
	var pt:st:pl3:init init;
	var st:io:call val, tmp, cast, ret;
	var u32 sz = 8 * pl3:agg_max(agg, &pl3:arch_x64);

	if(list->init == null)
		return io:call_str("undef");

	init = list->init;
	if(init->next != null)
		e:fmt("Internal error. Invalid union initializer.");

	val = e:get(emit_init(ctx, env, init));

	tmp = gen_tmp(ctx);
	cast = gen_tmp(ctx);
	ret = gen_tmp(ctx);

	e:get(io:fmt(ctx->vars, "\t%C = alloca i%u\n", tmp, sz));
	e:get(io:fmt(ctx->code, "\t%C = bitcast i%u* %C to %C*\n", cast, sz, tmp, call_type(&init->type)));
	e:get(io:fmt(ctx->code, "\tstore %C %C, %C* %C\n", call_type(&init->type), val, call_type(&init->type), cast));
	e:get(io:fmt(ctx->code, "\t%C = load i%u, i%u* %C\n", ret, sz, sz, tmp));

	return ret;
};

/**
 * Emit an array value.
 *   @ctx: The context.
 *   @env: The environment.
 *   @arr: The array type.
 *   @list; The initializer list.
 *   &returns: The result.
 */
def e:str[st:io:call](pt:st:ctx ctx, pt:st:env env, en:pl3:type tag, pt:st:pl3:arr arr, pt:st:pl3:list list) emit_arr = {
	var st:io:call type, val, elem, tmp;
	var pt:st:pl3:init init;

	val = io:call_str("undef");
	type = call_arr(arr);

	for(init = list->init; init != null; init = init->next) {
		elem = e:get(emit_init(ctx, env, init));

		tmp = gen_tmp(ctx);
		//e:get(io:fmt(ctx->code, "\t%C = insertelement %C %C, %C %C, i32 %d\n", tmp, type, val, call_type(&init->type), elem, init->idx));
		e:get(io:fmt(ctx->code, "\t%C = insertvalue %C %C, %C %C, %d\n", tmp, type, val, call_type(&init->type), elem, init->idx));
		val = tmp;
	}

	return val;
};

/**
 * Generate a temporary.
 *   @ctx: The context.
 *   &returns: The callback.
 */
def st:io:call(pt:st:ctx ctx) gen_tmp = {
	def e:str[void](st:io:file file, pt:void arg) func = {
		io:fmt(file, "%%t%u", u32{arg});
	};

	return st:io:call{ &func, pt:void{ctx->tmp++} };
};

/**
 * Generate a literal value.
 *   @lit: The literal.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:pl3:lit lit) gen_lit = {
	def e:str[void](st:io:file file, cpt:st:pl3:lit lit) func = {
		/* FIXME: we need a better io:fmt function */
		switch(lit->tag) {
		case ev:pl3:lit:bool: e:get(io:fmt(file, "%u", u32{lit->data.boolv})); break;
		case ev:pl3:lit:null: e:get(io:fmt(file, "zeroinitializer")); break;
		case ev:pl3:lit:i8v: e:get(io:fmt(file, "%d", i32{lit->data.i8v})); break;
		case ev:pl3:lit:u8v: e:get(io:fmt(file, "%u", u32{lit->data.u8v})); break;
		case ev:pl3:lit:i16v: e:get(io:fmt(file, "%d", i32{lit->data.i16v})); break;
		case ev:pl3:lit:u16v: e:get(io:fmt(file, "%u", u32{lit->data.u16v})); break;
		case ev:pl3:lit:i32v: e:get(io:fmt(file, "%d", lit->data.i32v)); break;
		case ev:pl3:lit:u32v: e:get(io:fmt(file, "%u", lit->data.u32v)); break;
		case ev:pl3:lit:i64v: e:get(io:fmt(file, "%d", i32{lit->data.i64v})); break;
		case ev:pl3:lit:u64v: e:get(io:fmt(file, "%u", u32{lit->data.u64v})); break;
		case ev:pl3:lit:int: e:fmt("Cannot emit big integer.");
		case ev:pl3:lit:fp32: {
			var u64 i;
			var fp64 f = cast_fp32tofp64(lit->data.fp32v);
			mem:copy(&i, &f, 8);
			e:get(io:fmt(file, "0x%p", i)); // TODO ugly but work
		} break;
		case ev:pl3:lit:fp64: {
			var u64 i;
			mem:copy(&i, &lit->data.fp64v, 8);
			e:get(io:fmt(file, "0x%p", i)); // TODO ugly but work
		} break;
		case ev:pl3:lit:flt: e:fmt("Cannot emit big float.");
		case ev:pl3:lit:ptr: e:get(io:fmt(file, "inttoptr (i32 %d to i8*)", m:int_get_i32(lit->data.int))); break; //FIXME very wrong
		default: fatal("FIXME stub lit %u", lit->tag);
		}

	};
	
	return st:io:call{ &func, lit };
};


tydef st:wrap {
	pt:st:ctx ctx;
	pt:st:pl3:expr expr;
};
def st:io:call(cpt:st:wrap wrap) wrap_call = {
	def e:str[void](st:io:file file, cpt:st:wrap wrap) func = {
		switch(wrap->expr->tag) {
		case ev:pl3:expr:lit:
			var pt:st:pl3:lit lit = wrap->expr->data.lit;

			switch(lit->tag) {
			case ev:pl3:lit:i32v: e:get(io:fmt(file, "%d", lit->data.i32v)); break;
			case ev:pl3:lit:u32v: e:get(io:fmt(file, "%u", lit->data.u32v)); break;
			case ev:pl3:lit:i64v: e:get(io:fmt(file, "%{i64}", lit->data.i64v)); break;
			case ev:pl3:lit:u64v: e:get(io:fmt(file, "%{u64}", lit->data.u64v)); break;
			case ev:pl3:lit:int: e:fmt("Cannot emit big integer.");
			default: fatal("FIXME stub");
			}

			break;

		default:
			fatal("FIXME");
		}
	};
	
	return st:io:call{ &func, pt:void{wrap} }; // FIXME: remove cast
};


/**
 * Retrieve a debug ID for a file.
 *   @ctx: The context.
 *   @file: The file string.
 *   &returns: The callback.
 */
def st:io:call(pt:st:ctx ctx, pt:st:pl3:str str) dbg_file = {
	def e:str[void](st:io:file file, pt:void arg) func = {
		io:fmt(file, "!%u", u32{arg});
	};

	var u32 id, cnt;

	cnt = ctx->dbgs.cnt;
	id = map_get(&ctx->dbgs, str);
	if(id >= cnt)
		io:fmt(ctx->ext, "!%u = !DIFile(filename: \"%s\", directory: \".\")\n", id, str->buf);

	return st:io:call{ &func, pt:void{id} };
};

/**
 * Retrieve a debug ID for a binding.
 *   @ctx: The context.
 *   @bind: The binding.
 *   @decl: The declaration for type information.
 *   &returns: The callback.
 */
def st:io:call(pt:st:ctx ctx, pt:st:pl3:bind bind, pt:st:pl3:decl decl) dbg_bind = {
	def e:str[void](st:io:file file, pt:void arg) func = {
		io:fmt(file, "!%u", u32{arg});
	};

	var u32 id, cnt;
	var st:io:call file;

	file = dbg_file(ctx, bind->meta.loc->file);

	cnt = ctx->dbgs.cnt;
	id = map_get(&ctx->dbgs, bind);
	if(id >= cnt) {
		var u32 ext = ctx->dbgs.cnt++;

		io:fmt(ctx->ext, "!%u = !DIGlobalVariableExpression(var: !%u, expr: !DIExpression())\n", id, ext);
		io:fmt(ctx->ext, "!%u = !DIGlobalVariable(name: \"%s\", file: %C, line: %u, type: !DIBasicType())\n", ext, bind->id, file, bind->meta.loc->lin + 1);
	}

	return st:io:call{ &func, pt:void{id} };
};


/**
 * Environment structure.
 *   @map: The variable mapping.
 *   @flow: The control flow.
 *   @scope: The scope.
 */
tydef st:env {
	pt:st:map map;
	pt:st:flow flow;
	pt:st:scope scope;
};


/**
 * Scope structure.
 *   @handler; The error handlers.
 *   @up: The previous scope.
 */
tydef st:scope {
	pt:st:handler err;
	pt:st:scope up;
};

/**
 * Handler structure.
 *   @stmt: The handler statement.
 *   @next; The next handler.
 */
tydef st:handler {
	pt:st:pl3:stmt stmt;
	pt:st:handler next;
};


/**
 * Identifier mapping.
 *   @tree: The pointer to identifier tree.
 *   @cnt: The current count of indentifiers.
 */
tydef st:map {
	st:avl:root tree;
	u32 cnt;
};

/**
 * Named mapping.
 *   @id: The integer identifier.
 *   @ptr: The store pointer value.
 *   @node: The tree node.
 */
tydef st:name {
	u32 id;
	cpt:void ptr;
	st:avl:node node;
};


/**
 * Control flow structure.
 *   @brk, cont: The break and continue labels.
 *   @up: The parent flow.
 */
tydef st:flow {
	u32 brk, cont;
	pt:st:flow up;
};


/**
 * Create a map.
 *   &returns: The map.
 */
def st:map() map_new = {
	return st:map{ avl:root_new(&avl:cmp_ptr), 0 };
};

/**
 * Destroy a map.
 *   @map: THe map.
 */
def void(st:map map) map_delete = {
	avl:root_delete(&map.tree, offsetof(st:name, node), &mem:free);
};

/**
 * Find an identifier, if it exists.
 *   @map: The map.
 *   @ptr: The pointer.
 *   &returns: The identifier if found, negative if not found.
 */
def i32(pt:st:map map, cpt:void ptr) map_find = {
	var pt:st:avl:node node;

	node = avl:root_get(&map->tree, ptr);
	return (node != null) ? i32{getparent(node, st:name, node)->id} : -1;
};

/**
 * Retrieve an identifier from a map or create if it does not exist.
 *   @map: The map.
 *   @decl: The pointer.
 *   &returns: The identifier.
 */
def u32(pt:st:map map, cpt:void ptr) map_get = {
	var pt:st:name name;
	var pt:st:avl:node node;

	node = avl:root_get(&map->tree, ptr);
	if(node == null) {
		name = mem:make(st:name{ map->cnt++, ptr, avl:node(ptr) });
		avl:root_add(&map->tree, &name->node);
	}
	else
		name = getparent(node, st:name, node);
	
	return name->id;
};


/**
 * Create a callback for a local.
 *   @id: The identifier.
 *   &returns: The callback.
 */
def st:io:call(u32 id) call_local = {
	def e:str[void](st:io:file file, pt:void arg) func = {
		io:fmt(file, "%%r%u", u32{arg});
	};

	return st:io:call{ &func, pt:void{id} };
};

/**
 * Create a callback for a label.
 *   @id: The identifier.
 *   &returns: The callback.
 */
def st:io:call(u32 id) call_lab = {
	def e:str[void](st:io:file file, pt:void arg) func = {
		io:fmt(file, "%%l%u", u32{arg});
	};

	return st:io:call{ &func, pt:void{id} };
};


/**
 * Parameter information structure.
 *   @ctx: The context.
 *   @param: The paremeter list.
 */
tydef st:pinfo {
	pt:st:ctx ctx;
	pt:st:pl3:param param;
	bool vlist;
};

/**
 * Create a callback for the parameters.
 *   @param: The parameter list.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:pinfo info) call_pinfo = {
	def e:str[void](st:io:file file, cpt:st:pinfo info) func = {
		var u32 i = 0;
		var pt:st:pl3:param param = info->param;

		while(param != null) {
			io:fmt(file, "%C", call_tyinfo(getref(st:tyinfo{ info->ctx, param->type })));

			if(param->id != null)
				io:fmt(file, " %%a%u", i++);

			param = param->next;
			if((param != null) || info->vlist)
				io:fmt(file, ", ");
		}

		if(info->vlist)
			e:get(io:fmt(file, "..."));
	};

	return st:io:call{ &func, info };
};

tydef st:arg {
	pt:st:pl3:type type;
	st:io:call val;
};

/**
 * Create a callback for an argument list.
 *   @args: The list of argument types and values.
 */
def st:io:call(pt:st:arg args) call_args = {
	def e:str[void](st:io:file file, cpt:st:arg arg) func = {
		while(arg->type != null) {
			io:fmt(file, "%C %C", call_type(arg->type), arg->val);

			arg = arg + 1; // FIXME
			if(arg->type != null)
				io:fmt(file, ", ");
		}
	};

	return st:io:call{ &func, args };
};


/**
 * Type information structure.
 *   @ctx: The context.
 *   @type: The type.
 */
tydef st:tyinfo {
	pt:st:ctx ctx;
	st:pl3:type type;
};

def st:io:call(cpt:st:tyinfo info) call_tyinfo = {
	def e:str[void](st:io:file file, cpt:st:tyinfo info) func = {
		e:get(io:fmt(file, "%C", call_type(&info->type)));
	};

	return st:io:call{ &func, info };
};

/**
 * Create a callback for an arbitrary type.
 *   @type: The type pointer.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:pl3:type type) call_type = {
	def e:str[void](st:io:file file, cpt:st:pl3:type type) func = {
		switch(type->tag) {
		case ev:pl3:type:unk: e:fmt("Unresolved type.");
		case ev:pl3:type:void: e:get(io:fmt(file, "void")); break;
		case ev:pl3:type:bool: e:get(io:fmt(file, "i8")); break;
		case ev:pl3:type:i8: e:get(io:fmt(file, "i8")); break;
		case ev:pl3:type:u8: e:get(io:fmt(file, "i8")); break;
		case ev:pl3:type:i16: e:get(io:fmt(file, "i16")); break;
		case ev:pl3:type:u16: e:get(io:fmt(file, "i16")); break;
		case ev:pl3:type:i32: e:get(io:fmt(file, "i32")); break;
		case ev:pl3:type:u32: e:get(io:fmt(file, "i32")); break;
		case ev:pl3:type:i64: e:get(io:fmt(file, "i64")); break;
		case ev:pl3:type:u64: e:get(io:fmt(file, "i64")); break;
		case ev:pl3:type:fp32: e:get(io:fmt(file, "float")); break;
		case ev:pl3:type:fp64: e:get(io:fmt(file, "double")); break;

		case ev:pl3:type:ptr:
			e:get(io:fmt(file, "i8*"));
			break;

		case ev:pl3:type:arr: {
			var pt:st:pl3:arr arr = type->data.arr;

			e:get(io:fmt(file, "[%u x %C]", arr->len, call_type(&arr->type)));
		} break;

		case ev:pl3:type:name: {
			var pt:st:pl3:tydecl decl;
			var pt:st:pl3:name name = type->data.name;

			if(name->decl == null)
				e:fmt("Internal error. Unresolved named type.");

			decl = name->decl;
			switch(decl->tag) {
			case ev:pl3:tydecl:enum:
				e:get(io:fmt(file, "i32")); // FIXME different widths.
				break;

			case ev:pl3:tydecl:alias:
				e:get(io:fmt(file, "%C", call_type(&decl->data.alias->type)));
				break;

			case ev:pl3:tydecl:struct: {
				var pt:st:pl3:memb memb;
				var pt:st:pl3:field field;
				var pt:st:pl3:agg agg = decl->data.agg;
				
				e:get(io:fmt(file, "{"));

				for(memb = agg->memb; memb != null; memb = memb->next) {
					for(field = memb->field; field != null; field = field->next) {
						e:get(io:fmt(file, "%C", call_type(&memb->type)));

						if((field->next != null) || (memb->next != null))
							e:get(io:fmt(file, ", "));
					}
				}

				e:get(io:fmt(file, "}"));
			} break;

			case ev:pl3:tydecl:union:
				e:get(io:fmt(file, "i%u", 8 * pl3:type_size(*type, &pl3:arch_x64)));
				break;
			}

		} break;

		case ev:pl3:type:sig:
			e:get(io:fmt(file, "%C", call_sig(type->data.sig)));
			break;

		case ev:pl3:type:args:
			e:get(io:fmt(file, "%%\"$args\""));
			break;

		case ev:pl3:type:err: {
			var cpt:st:pl3:err err = type->data.err;

			if(pl3:type_is_void(err->suc))
				e:get(io:fmt(file, "%C", call_type(&err->fail)));
			else
				e:get(io:fmt(file, "{%C,%C}", call_type(&err->suc), call_type(&err->fail)));
		} break;

		default: fatal("FIXME call type %d", type->tag);
		}
	};

	return st:io:call{ &func, type };
};

/**
 * Create a callback for a structure type.
 *   @agg: The aggregate.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:pl3:agg agg) call_struct = {
	def e:str[void](st:io:file file, cpt:st:pl3:agg agg) func = {
		var pt:st:pl3:memb memb;
		var pt:st:pl3:field field;
		
		e:get(io:fmt(file, "{"));

		for(memb = agg->memb; memb != null; memb = memb->next) {
			for(field = memb->field; field != null; field = field->next) {
				e:get(io:fmt(file, "%C", call_type(&memb->type)));

				if((field->next != null) || (memb->next != null))
					e:get(io:fmt(file, ", "));
			}
		}

		e:get(io:fmt(file, "}"));
	};

	return st:io:call{ &func, agg};
};

/**
 * Create a callback for an array type.
 *   @arr: The array type.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:pl3:arr arr) call_arr = {
	def e:str[void](st:io:file file, cpt:st:pl3:arr arr) func = {
		e:get(io:fmt(file, "[%u x %C]", arr->len, call_type(&arr->type)));
	};

	return st:io:call{ &func, arr };
};

tydef st:siginfo {
	pt:st:ctx ctx;
	cpt:st:pl3:sig sig;
};

/**
 * Create a callback for a function signature.
 *   @type: The function signature.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:pl3:sig sig) call_sig = {
	def e:str[void](st:io:file file, cpt:st:pl3:sig sig) func = {
		var cpt:st:pl3:param param = sig->param;

		e:get(io:fmt(file, "%C(", call_type(&sig->ret)));

		while(param != null) {
			io:fmt(file, "%C", call_type(&param->type));

			param = param->next;
			if((param != null) || sig->vlist)
				io:fmt(file, ", ");
		}

		if(sig->vlist)
			e:get(io:fmt(file, "..."));

		e:get(io:fmt(file, ")"));
	};

	return st:io:call{ &func, sig };
};


/**
 * Calculation structure.
 *   @ctx: The context.
 *   @env: The environment.
 *   @expr: The expression.
 */
tydef un:calc { pt:st:pl3:comp comp; };
tydef st:calc {
	pt:st:ctx ctx;
	pt:st:env env;
	pt:st:pl3:expr expr;
	un:calc data;
};

/**
 * Calculate a constant for an expression.
 *   @expr: The expression.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:calc info) calc_expr = {
	def e:str[void](st:io:file file, cpt:st:calc info) func = {
		var cpt:st:pl3:expr expr = info->expr;

		switch(expr->tag) {
		case ev:pl3:expr:lit: {
			var pt:st:pl3:lit lit = expr->data.lit;

			if(lit->tag == ev:pl3:lit:str) {
				var u32 i, sz, num;
				var pt:char str;
				var st:str:buf buf;

				num = info->ctx->str++;
				sz = lit->data.buf->sz;
				buf = str:buf_new(sz + 1);

				for(i = 0; i < sz; i++) {
					var char ch = lit->data.buf->arr[i];

					if(lex:is_alnum(i16{ch})) // FIXME, ch:is_alnum??
						str:buf_add_ch(&buf, ch);
					else {
						var u8 val;

						str:buf_add_ch(&buf, '\\');
						val = (ch >> 4);
						str:buf_add_ch(&buf, (val >= 10) ? ('a' + val - 10) : ('0' + val));
						val = (ch & 0xF);
						str:buf_add_ch(&buf, (val >= 10) ? ('a' + val - 10) : ('0' + val));
					}
				}
				
				str = str:buf_done(&buf);
				onerr mem:free(str);

				e:get(io:fmt(info->ctx->ext, "@s%u = internal local_unnamed_addr constant [%u x i8] c\"%s\", align 1\n", num, sz, str));
				e:get(io:fmt(file, "getelementptr inbounds([%u x i8], [%u x i8]* @s%u, i64 0, i64 0)", sz, sz, num));

				mem:free(str);
			}
			else {
				/* FIXME: we need a better io:fmt function */
				switch(lit->tag) {
				case ev:pl3:lit:bool: e:get(io:fmt(file, "%u", u32{lit->data.boolv})); break;
				case ev:pl3:lit:null: e:get(io:fmt(file, "zeroinitializer")); break;
				case ev:pl3:lit:i8v: e:get(io:fmt(file, "%d", i32{lit->data.i8v})); break;
				case ev:pl3:lit:u8v: e:get(io:fmt(file, "%u", u32{lit->data.u8v})); break;
				case ev:pl3:lit:i16v: e:get(io:fmt(file, "%d", i32{lit->data.i16v})); break;
				case ev:pl3:lit:u16v: e:get(io:fmt(file, "%u", u32{lit->data.u16v})); break;
				case ev:pl3:lit:i32v: e:get(io:fmt(file, "%d", lit->data.i32v)); break;
				case ev:pl3:lit:u32v: e:get(io:fmt(file, "%u", lit->data.u32v)); break;
				case ev:pl3:lit:i64v: e:get(io:fmt(file, "%d", i32{lit->data.i64v})); break;
				case ev:pl3:lit:u64v: e:get(io:fmt(file, "%u", u32{lit->data.u64v})); break;
				case ev:pl3:lit:ptr: e:get(io:fmt(file, "inttoptr(i64 %u to i8*)", u32{m:int_get_u64(lit->data.int)})); break; // TODO not this
				case ev:pl3:lit:int: e:fmt("Internal error. Cannot emit big integer.");
				default: fatal("FIXME stub calc_expr lit %u", lit->tag);
				}
			}
		} break;

		case ev:pl3:expr:ident: {
			var pt:st:pl3:ident ident = expr->data.ident;

			if(ident->tag == ev:pl3:ident:link) {
				var st:io:call calc;
				var st:pl3:link link = ident->data.link;

				if((link.decl->flags & pl3:decl:mut) != 0)
					e:fmt("Internal error. Mutable variable used in constant expression.");

				calc = calc_expr(getref(st:calc{ info->ctx, info->env, link.bind->expr }));
				e:get(io:fmt(file, "%C", calc));
			}
			else
				fatal("FIXME what error");
		} break;

		case ev:pl3:expr:op1: {
			var pt:st:pl3:op1 op1 = expr->data.op1;
			var st:io:call type = call_type(&op1->in->type);

			switch(op1->tag) {
			case ev:pl3:op1:neg: {
				var st:io:call calc = calc_expr(getref(st:calc{ info->ctx, info->env, op1->in }));

				e:get(io:fmt(file, "sub(%C 0, %C %C)", type, type, calc));
			} break;

			case ev:pl3:op1:addr:
				switch(op1->in->tag) {
				case ev:pl3:expr:ident: {
					var i32 id;
					var st:io:call val;
					var pt:st:pl3:ident ident = op1->in->data.ident;

					if(ident->tag != ev:pl3:ident:link)
						e:fmt("Internal error. Invalid constant expression identifier.");

					id = map_find(info->env->map, ident->data.link.bind);
					if(id >= 0)
						val = call_local(u32{id});
					else
						val = ref_bind(info->ctx, ident->data.link.bind);

					e:get(io:fmt(file, "bitcast (%C* %C to i8*)", call_type(&ident->data.link.decl->type), val));
				} break;
					
				default:
					e:fmt("Internal error. Unsupported constant expression.");
				}

				break;

			default:
				e:fmt("Internal error. Unsupported constant expression.");
			}
		} break;

		case ev:pl3:expr:op2: {
			var cpt:char code;
			var st:io:call lhs, rhs;
			var pt:st:pl3:op2 op2 = expr->data.op2;

			switch(op2->tag) {
			case ev:pl3:op2:assign:
			case ev:pl3:op2:addeq:
			case ev:pl3:op2:subeq:
			case ev:pl3:op2:muleq:
			case ev:pl3:op2:diveq:
			case ev:pl3:op2:remeq:
			case ev:pl3:op2:andeq:
			case ev:pl3:op2:oreq:
			case ev:pl3:op2:xoreq:
			case ev:pl3:op2:shleq:
			case ev:pl3:op2:shreq:
				e:fmt("Internal error. Unsupported constant expression.");

			// FIXME support floats
			case ev:pl3:op2:add: code = "add"; break;
			case ev:pl3:op2:sub: code = "sub"; break;
			case ev:pl3:op2:mul: code = "mul"; break;
			case ev:pl3:op2:div: code = "div"; break;
			case ev:pl3:op2:rem: code = "rem"; break;
			case ev:pl3:op2:and: code = "and"; break;
			case ev:pl3:op2:or: code = "or"; break;
			case ev:pl3:op2:xor: code = "xor"; break;
			case ev:pl3:op2:shl: code = "shl"; break;
			case ev:pl3:op2:shr: code = "shr"; break;

			case ev:pl3:op2:land:
			case ev:pl3:op2:lor:
				fatal("FIXME stub");

			case ev:pl3:op2:eq:
			case ev:pl3:op2:ne:
			case ev:pl3:op2:lt:
			case ev:pl3:op2:lte:
			case ev:pl3:op2:gt:
			case ev:pl3:op2:gte:
				fatal("FIXME stub");
			}

			lhs = calc_expr(getref(st:calc{ info->ctx, info->env, op2->lhs }));
			rhs = calc_expr(getref(st:calc{ info->ctx, info->env, op2->rhs }));
			e:get(io:fmt(file, "%s(%C %C, %C %C)", code, call_type(&op2->lhs->type), lhs, call_type(&op2->rhs->type), rhs));
		} break;

		case ev:pl3:expr:comp:
			e:get(io:fmt(file, "%C", calc_comp(getref(st:calc{ info->ctx, info->env, null, { .comp = expr->data.comp } }))));
			break;

		case ev:pl3:expr:enref: {
			e:get(io:fmt(file, "%C", calc_expr(getref(st:calc{ info->ctx, info->env, expr->data.enref->val->expr }))));
		} break;

		default:
			e:fmt("Internal error. Unsupported constant expression (tag=%u).", expr->tag);
		}
	};

	return st:io:call{ &func, info };
};

/**
 * Calculate a constant for a compound.
 *   @expr: The expression.
 *   &returns: The callback.
 */
def st:io:call(cpt:st:calc info) calc_comp = {
	def e:str[void](st:io:file file, cpt:st:calc info) func = {
		var pt:st:pl3:agg agg;
		var pt:st:pl3:arr arr;
		var pt:st:pl3:comp comp = info->data.comp;
		var pt:st:pl3:list list = comp->list;

		if((arr = pl3:type_get_arr(comp->type)) != null) {
			var pt:st:pl3:init init;

			e:get(io:fmt(file, "["));

			for(init = list->init; init != null; init = init->next) {
				e:get(io:fmt(file, "%C ", call_type(&arr->type)));

				switch(init->tag) {
				case ev:pl3:init:nest: {
					var st:pl3:comp comp = { arr->type, init->data.list };
					var st:io:call calc = calc_comp(getref(st:calc{ info->ctx, info->env, null, { .comp = &comp } }));

					e:get(io:fmt(file, "%C", calc));
				} break;

				case ev:pl3:init:expr: {
					var st:io:call calc = calc_expr(getref(st:calc{ info->ctx, info->env, init->data.expr }));

					e:get(io:fmt(file, "%C", calc));
				} break;
				}

				if(init->next != null)
					e:get(io:fmt(file, ", "));
			}

			e:get(io:fmt(file, "]"));
		}
		else if((agg = pl3:type_get_agg(comp->type, null)) != null) {
			var pt:st:pl3:init init;
			var u32 i, cnt = pl3:agg_cnt(agg);

			e:get(io:fmt(file, "{"));

			for(i = 0; i < cnt; i++) {
				var st:pl3:type type;

				if(i > 0)
					e:get(io:fmt(file, ", "));

				pl3:agg_get(agg, i, &type);
				e:get(io:fmt(file, "%C ", call_type(&type)));

				for(init = list->init; init != null; init = init->next) {
					if(init->idx != i32{i})
						continue;

					switch(init->tag) {
					case ev:pl3:init:nest:
						fatal("FIXME stub init const nest");

					case ev:pl3:init:expr: {
						var st:io:call calc = calc_expr(getref(st:calc{ info->ctx, info->env, init->data.expr }));

						e:get(io:fmt(file, "%C", calc));
					} break;
					}

					break; // FIXME replace with continue(2)
				}

				if(init == null)
					e:get(io:fmt(file, "zeroinitializer"));
			}

			e:get(io:fmt(file, "}"));
		}
		else {
			fatal("FIXME stub cast const");
		}
	};

	return st:io:call{ &func, info };
};


/**
 * Value structure.
 *   @tag: The type tag.
 *   @data: The data.
 */
tydef[export] un:pl3:val { i8 i8v; u8 u8v; i16 i16v; u16 u16v; i32 i32v; u32 u32v; i64 i64v; u64 u64v; };
tydef[export] st:pl3:val {
	en:pl3:type tag;
	un:pl3:val data;
};

/**
 * Calculate a value from an expression, if possible.
 *   @expr: The expression.
 *   &returns: The value.
 */
def[export] st:pl3:val(pt:st:pl3:expr expr) pl3:val_calc = {
	switch(expr->tag) {
	case ev:pl3:expr:lit: {
		var pt:st:pl3:lit lit = expr->data.lit;

		switch(lit->tag) {
		case ev:pl3:lit:i8v: return st:pl3:val{ ev:pl3:type:i8, { .i8v = lit->data.i8v } };
		case ev:pl3:lit:u8v: return st:pl3:val{ ev:pl3:type:u8, { .u8v = lit->data.u8v } };
		case ev:pl3:lit:i16v: return st:pl3:val{ ev:pl3:type:i16, { .i16v = lit->data.i16v } };
		case ev:pl3:lit:u16v: return st:pl3:val{ ev:pl3:type:u16, { .u16v = lit->data.u16v } };
		case ev:pl3:lit:i32v: return st:pl3:val{ ev:pl3:type:i32, { .i32v = lit->data.i32v } };
		case ev:pl3:lit:u32v: return st:pl3:val{ ev:pl3:type:u32, { .u32v = lit->data.u32v } };
		case ev:pl3:lit:i64v: return st:pl3:val{ ev:pl3:type:i64, { .i64v = lit->data.i64v } };
		case ev:pl3:lit:u64v: return st:pl3:val{ ev:pl3:type:u64, { .u64v = lit->data.u64v } };
		default: fatal("FIXME: the rest of these");
		}
	} break;

	case ev:pl3:expr:ident: {
		var pt:st:pl3:ident ident = expr->data.ident;

		if(ident->tag == ev:pl3:ident:link) {
			var st:pl3:link link = ident->data.link;

			if((link.decl->flags & pl3:decl:mut) == 0)
				return pl3:val_calc(link.bind->expr);
		}
	} break;

	case ev:pl3:expr:op1: {
		var pt:st:pl3:op1 op1 = expr->data.op1;
		var st:pl3:val val = pl3:val_calc(op1->in);

		switch(op1->tag) {
		case ev:pl3:op1:neg:
			switch(val.tag) {
			case ev:pl3:lit:i8v: val.data.i8v = -val.data.i8v; break;
			case ev:pl3:lit:u8v: val.data.u8v = -val.data.u8v; break;
			case ev:pl3:lit:i16v: val.data.i16v = -val.data.i16v; break;
			case ev:pl3:lit:u16v: val.data.u16v = -val.data.u16v; break;
			case ev:pl3:lit:i32v: val.data.i32v = -val.data.i32v; break;
			case ev:pl3:lit:u32v: val.data.u32v = -val.data.u32v; break;
			case ev:pl3:lit:i64v: val.data.i64v = -val.data.i64v; break;
			case ev:pl3:lit:u64v: val.data.u64v = -val.data.u64v; break;
			default: fatal("FIXME: the rest of these");
			}
			break;
		}

		return val;
	} break;
	}


	return st:pl3:val{ ev:pl3:type:unk, {}};
};

def[export] st:io:call(cpt:st:pl3:val val) pl3:val_call = {
	def e:str[void](st:io:file file, cpt:st:pl3:val val) func = {
		/* FIXME: we need a better io:fmt function */
		switch(val->tag) {
		case ev:pl3:type:i8: io:fmt(file, "%d", i32{val->data.i8v}); break;
		case ev:pl3:type:u8: io:fmt(file, "%u", u32{val->data.u8v}); break;
		case ev:pl3:type:i16: io:fmt(file, "%d", i32{val->data.i16v}); break;
		case ev:pl3:type:u16: io:fmt(file, "%u", u32{val->data.u16v}); break;
		case ev:pl3:type:i32: io:fmt(file, "%d", val->data.i32v); break;
		case ev:pl3:type:u32: io:fmt(file, "%u", val->data.u32v); break;
		case ev:pl3:type:i64: io:fmt(file, "%d", i32{val->data.i64v}); break;
		case ev:pl3:type:u64: io:fmt(file, "%u", u32{val->data.u64v}); break;
		default: fatal("FIXME: the rest of these");
		}
	};

	return st:io:call{ &func, val };
};



/**
 * Scope structure.
 *   @type, enum, val: The types, enumeator, and value trees.
 *   @up; The parent scope.
 */
tydef[export] st:pl3:scope {
	st:avl:root type, enum, val;
	pt:st:pl3:scope up;
};

/**
 * Create a new scope.
 *   @up; The parent scope.
 *   &returns: The scope.
 */
def pt:st:pl3:scope(pt:st:pl3:scope up) pl3:scope_new = {
	return mem:make(st:pl3:scope{ {}, {}, {}, up });
};

/**
 * Delete a scope.
 *   @scope: The scope.
 */
def void(pt:st:pl3:scope scope) pl3:scope_delete = {
	mem:free(scope);
};


/**
 * Reference structure.
 *   @id: The identifier.
 *   @tag: The reference type tag.
 *   @ptr: The pointer.
 *   @node: The tree node.
 */
tydef en:ref { bind, func };
tydef st:ref {
	u32 id;
	st:io:call call;
	cpt:void ptr;

	st:avl:node node;
};

/**
 * Get a reference from a context.
 *   @ctx: The context.
 *   @tag: The tag.
 *   @ptr: The pointer.
 *   &returns: The reference.
 */
def pt:st:ref(pt:st:ctx ctx, en:ref tag, cpt:void ptr) ref_get = {
	var pt:st:ref ref;
	var pt:st:avl:node node;

	def e:str[void](st:io:file file, cpt:void arg) proc = {
		e:get(io:fmt(file, "@\"$v%u\"", u32{arg}));
	};

	node = avl:root_get(&ctx->refs, ptr);
	if(node == null) {
		ref = mem:make(st:ref{ ctx->refs.cnt, { &proc, pt:void{ ctx->refs.cnt } }, ptr, avl:node(ptr) });
		avl:root_add(&ctx->refs, &ref->node);
	}
	else
		ref = getparent(node, st:ref, node);
	
	return ref;
};

/**
 * Get a reference name for a function.
 *   @ctx: The context.
 *   @func: The function.
 *   &returns: The name.
 */
def st:io:call(pt:st:ctx ctx, cpt:st:pl3:func func) ref_func = {
	return ref_bind(ctx, func);
	/*
	def e:str[void](st:io:file file, cpt:void arg) proc = {
		e:get(io:fmt(file, "@\"$f%u\"", u32{arg}));
	};

	return st:io:call{ &proc, cpt:void{ref_get(ctx, ev:ref:func, func)->id} };
	*/
};

/**
 * Get a reference name for a function.
 *   @ctx: The context.
 *   @func: The function.
 *   &returns: The name.
 */
def st:io:call(pt:st:ctx ctx, cpt:st:pl3:bind bind) ref_bind = {
	return ref_get(ctx, ev:ref:bind, bind)->call;
};


def e:str[void](st:io:file file, cpt:st:pl3:bind bind) ext_proc = {
	e:get(io:fmt(file, "@\"%s\"", bind->id));
};
def st:io:call(pt:st:ctx ctx, pt:st:pl3:bind bind) ref_external = {

	return ref_put(ctx, bind, st:io:call{ &ext_proc, bind })->call;
};


/**
 * Find a reference.
 *   @ctx: The context.
 *   @ptr: The pointer.
 *   &returns: The reference or null if not found.
 */
def pt:st:ref(pt:st:ctx ctx, cpt:void ptr) ref_find = {
	var pt:st:avl:node node;

	node = avl:root_get(&ctx->refs, ptr);
	if(node == null)
		return null;

	return getparent(node, st:ref, node);
	
};

/**
 * Add a reference.
 *   @ctx: The context.
 *   @ptr: The pointer.
 *   @call: The call.
 *   &jeturns: The reference.
 */
def pt:st:ref(pt:st:ctx ctx, cpt:void ptr, st:io:call call) ref_put = {
	var pt:st:ref ref;

	ref = mem:make(st:ref{ ctx->refs.cnt, call, ptr, avl:node(ptr) });
	avl:root_add(&ctx->refs, &ref->node);

	return ref;
};

/**
 * Create a unique reference, if it doesn't exist already..
 *   @ctx: The context.
 *   @ptr: The pointer.
 *   &returns: The call.
 */
def st:io:call(pt:st:ctx ctx, cpt:void ptr) ref_uniq = {
	def e:str[void](st:io:file file, cpt:void arg) proc = {
		e:get(io:fmt(file, "@\"$v%u\"", u32{arg}));
	};

	var pt:st:ref ref;

	ref = ref_find(ctx, ptr);
	if(ref == null)
		ref = ref_put(ctx, ptr, st:io:call{ &proc, pt:void{ ctx->refs.cnt } });

	return ref->call;
};


/**
 * Create a scope.
 *   @up: The parent scope.
 *   &returns: The scope.
 */
def st:scope(pt:st:scope up) scope_new = {
	return st:scope{ null, up };
};

/**
 * Delete a scope.
 *   @scope: The scope.
 */
def void(st:scope scope) scope_delete = {
	var pt:st:handler tmp;

	while(scope.err != null) {
		scope.err = (tmp = scope.err)->next;
		mem:free(tmp);
	}
};

/**
 * Add an error handler to the scope.
 *   @scope: The scope.
 *   @stmt: The statement.
 */
def void(pt:st:scope scope, pt:st:pl3:stmt stmt) scope_err = {
	scope->err = mem:make(st:handler{ stmt, scope->err });
};

def e:str[void](pt:st:scope scope, pt:st:ctx ctx, pt:st:env env) scope_emit = {
	while(scope != null) {
		var pt:st:handler handler;

		for(handler = scope->err; handler != null; handler = handler->next)
			e:get(ctx_stmt(ctx, env, handler->stmt));

		scope = scope->up;
	}
};


def e:str[st:io:call](pt:st:ctx ctx, st:io:call val) mk_bool = {
	var st:io:call ret;

	ret = gen_tmp(ctx);
	e:get(io:fmt(ctx->code, "  %C = trunc i8 %C to i1\n", ret, val));

	return ret;
};
