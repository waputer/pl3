// TODO all the functions should carry the return type, not the full function
// signature


tydef[export] st:pl3:diag {
	pt:char str;
	pt:st:pl3:diag next;
};

/**
 * Context structure.
 *   @diag: The diagnostic list.
 *   @top, unit: The top and code unit environments.
 */
tydef st:ctx {
	pt:pt:st:pl3:diag diag;
	pt:st:env top, unit;
};

/**
 * Environment.
 *   @map: The variable mapping.
 *   @sw: The current swtich.
 *   @depth: The break/continue nesting depth.
 */
tydef st:env {
	pt:st:map map;
	pt:st:pl3:sw sw;
	u32 depth;
};

/**
 * Map structure.
 *   @up: The up (or parent) environment.
 *   @names, types: The tree of names and types.
 *   @unit: The code unit.
 */
tydef st:map {
	st:avl:root names, types;
	pt:st:map up;
};

/**
 * Name structure.
 *   @param: The parameter.
 *   @decl: The declaration.
 *   @bind: The binding.
 *   @node: The node.
 */
tydef st:name {
	pt:st:pl3:param param;
	pt:st:pl3:decl decl;
	pt:st:pl3:bind bind;
	st:avl:node node;
};

/**
 * Type declaration structure.
 *   @decl: The type defintion.
 *   @node: The node.
 */
tydef st:type {
	pt:st:pl3:tydecl decl;
	st:avl:node node;
};

// FIXME: good grief this naming is terrible
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:stmt stmt, bool pub) foo = {
	switch(stmt->tag) {
	case ev:pl3:stmt:decl: {
		var pt:st:pl3:bind bind;
		var pt:st:pl3:decl decl = stmt->data.decl;

		if(((decl->flags & pl3:decl:pub) != 0) == pub) {
			for(bind = decl->bind; bind != null; bind = bind->next) {
				if(env_name_find(env, bind->id) != null)
					return ctx_err(ctx, "%C: Duplication declaration of '%s'.", pl3:meta_call(&stmt->meta), bind->id);

				env_name_bind(env, decl, bind);
			}
		}
	} break;

	case ev:pl3:stmt:tydecl: {
		var pt:st:pl3:tydecl decl = stmt->data.tydecl;

		if(((decl->flags & pl3:decl:pub) != 0) == pub)
			env_type_add(env, decl);
	} break;
	}
};


/**
 * Perform typechecking from the top-level.
 *   @top: The top-level.
 *   &returns: The error list.
 */
def[export] pt:st:pl3:diag(pt:st:pl3:top top) pl3:check = {
	var st:ctx ctx;
	var pt:st:pl3:unit unit;
	var pt:st:pl3:stmt stmt;
	var st:env env, nest;
	var pt:st:pl3:diag diag = null;

	env = env_top();
	onerr env_delete(env);

	ctx.diag = &diag;
	ctx.top = &env;

	for(unit = top->unit; unit != null; unit = unit->next) {
		for(stmt = unit->stmt; stmt != null; stmt = stmt->next)
			foo(&ctx, &env, stmt, true);
	}

	// TODO it should probably clean up the order this is done, maybe
	// just do a pass for types, then a pass for everything else
	for(unit = top->unit; unit != null; unit = unit->next) {
		for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
			if(stmt->tag == ev:pl3:stmt:tydecl) {
				var pt:st:pl3:tydecl decl = stmt->data.tydecl;

				if((decl->flags & pl3:decl:pub) != 0)
					ctx_tydecl(&ctx, &env, decl);
			}
		}
	}

	for(unit = top->unit; unit != null; unit = unit->next) {
		nest = env_map(&env);
		onerr env_delete(nest);

		for(stmt = unit->stmt; stmt != null; stmt = stmt->next)
			foo(&ctx, &nest, stmt, false);

		for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
			if(stmt->tag == ev:pl3:stmt:decl)
				ctx_type(&ctx, &nest, stmt->data.decl->type, &stmt->data.decl->meta);
		}

		env_delete(nest);
	}

	for(unit = top->unit; unit != null; unit = unit->next) {
		nest = env_map(&env);
		onerr env_delete(nest);

		ctx.top = &nest;
		ctx.unit = &nest;

		for(stmt = unit->stmt; stmt != null; stmt = stmt->next)
			foo(&ctx, &nest, stmt, false);

		for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
			if(stmt->tag == ev:pl3:stmt:tydecl) {
				var pt:st:pl3:tydecl decl = stmt->data.tydecl;

				if((decl->flags & pl3:decl:pub) == 0)
					ctx_tydecl(&ctx, &nest, stmt->data.tydecl);
			}
		}

		for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
			if(stmt->tag == ev:pl3:stmt:decl)
				ctx_decl(&ctx, &nest, stmt->data.decl, null);
		}

		env_delete(nest);
	}

	env_delete(env);

	return diag;
};

/**
 * Perform typechecking, producing a brief overview of errors (maximum of 5
 * reported errors.
 *   @top: The top-level.
 */
def[export] e:str[void](pt:st:pl3:top top) pl3:check_brief = {
	var st:str:buf buf;
	var pt:st:pl3:diag diag, iter;
	var u32 i = 0;

	diag = pl3:check(top);
	if(diag == null)
		return;

	buf = str:buf_new(256);

	for(iter = diag; iter != null; iter = iter->next) {
		if(i++ >= 5) {
			str:buf_add_str(&buf, "Truncating error list.\n");
			break;
		}

		str:buf_add_str(&buf, iter->str);
		str:buf_add_ch(&buf, '\n');
	}

	pl3:diag_delete(diag);
	e:ret(str:buf_done(&buf));
};

/**
 * Typecheck a declaration.
 *   @ctx: The context.
 *   @env: The environment.
 *   @decl: The declaration.
 *   @sig: The current function signature.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:decl decl, pt:st:pl3:sig sig) ctx_decl = {
	var pt:st:pl3:bind bind;

	ctx_type(ctx, env, decl->type, &decl->meta);

	for(bind = decl->bind; bind != null; bind = bind->next) {
		env_name_bind(env, decl, bind);

		var pt:st:pl3:arr arr;

		if((arr = pl3:type_get_arr(decl->type)) != null) {
			if(arr->len == 0) {
				if(bind->expr == null)
					return ctx_err(ctx, "%C: Variable length array must have compound initializer.", pl3:meta_call(&decl->meta));

				if(bind->expr->tag != ev:pl3:expr:comp)
					return ctx_err(ctx, "%C: Variable length array must have compound initializer.", pl3:meta_call(&decl->meta));

				arr->len = pl3:list_len(bind->expr->data.comp->list);
				pl3:type_replace(&bind->expr->data.comp->type, pl3:type_copy(decl->type));
			}
		}

		if(bind->expr == null)
			continue;

		ctx_expr(ctx, env, bind->expr, sig);

		if(bind->expr->type.tag == ev:pl3:type:unk)
			ctx_fill(bind->expr, decl->type);
	}
};

/**
 * Typecheck a block.
 *   @ctx: The context.
 *   @env: The environment.
 *   @block: The block.
 *   @sig: The signature.
 */
def void(pt:st:ctx ctx, pt:st:env env, st:pl3:block block, pt:st:pl3:sig sig) ctx_block = {
	var st:env nest;
	var pt:st:pl3:stmt stmt;

	nest = env_map(env);
	onerr env_delete(nest);

	for(stmt = block.stmt; stmt != null; stmt = stmt->next)
		ctx_stmt(ctx, &nest, stmt, sig);

	env_delete(nest);
};


/**
 * Typecheck a statement.
 *   @ctx: The context.
 *   @env: The environment.
 *   @stmt: The statement.
 *   @sig: The current function signature.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:stmt stmt, pt:st:pl3:sig sig) ctx_stmt = {
	switch(stmt->tag) {
	case ev:pl3:stmt:decl:
		ctx_decl(ctx, env, stmt->data.decl, sig);
		break;

	case ev:pl3:stmt:expr:
		ctx_expr(ctx, env, stmt->data.expr, sig);
		break;

	case ev:pl3:stmt:ret: {
		var pt:st:pl3:expr expr = stmt->data.expr;

		if(expr != null) {
			ctx_expr(ctx, env, expr, sig);

			if(pl3:type_is_unk(expr->type)) {
				var pt:st:pl3:err err;
				var st:pl3:type type;

				err = pl3:type_get_err(sig->ret);
				type = (err != null) ? err->suc : sig->ret;
				ctx_fill(expr, pl3:type_is_void(type) ? pl3:type_u32 : type);
			}
		}
		else {
			var pt:st:pl3:err err;

			if((err = pl3:type_get_err(sig->ret)) != null) {
				if(!pl3:type_is_void(err->suc))
					return ctx_err(ctx, "%C: Non-void function must return a value.", pl3:meta_call(&stmt->meta));
			}
			else if(!pl3:type_is_void(sig->ret))
				return ctx_err(ctx, "%C: Non-void function must return a value.", pl3:meta_call(&stmt->meta));
		}
	} break;

	case ev:pl3:stmt:block:
		ctx_block(ctx, env, stmt->data.block, sig);
		break;

	case ev:pl3:stmt:cond: {
		var pt:st:pl3:cond cond = stmt->data.cond;

		ctx_expr(ctx, env, cond->eval, sig);

		if(pl3:type_is_unk(cond->eval->type))
			ctx_fill(cond->eval, pl3:type_bool);

		if(!pl3:type_is_bool(cond->eval->type))
			ctx_err(ctx, "%C: Expected boolean.", pl3:meta_call(&cond->eval->meta));

		if(cond->ontrue != null)
			ctx_stmt(ctx, env, cond->ontrue, sig);

		if(cond->onfalse != null)
			ctx_stmt(ctx, env, cond->onfalse, sig);
	} break;

	case ev:pl3:stmt:loop: {
		var st:env nest;
		var pt:st:pl3:loop loop = stmt->data.loop;

		if(loop->init != null)
			ctx_expr(ctx, env, loop->init, sig);

		if(loop->eval != null) {
			ctx_expr(ctx, env, loop->eval, sig);

			if(!pl3:type_is_bool(loop->eval->type))
				return ctx_err(ctx, "%C: Expected boolean.", pl3:meta_call(&loop->eval->meta));
		}

		if(loop->inc != null)
			ctx_expr(ctx, env, loop->inc, sig);

		nest = st:env{ env->map, env->sw, env->depth + 1 };
		ctx_stmt(ctx, &nest, loop->body, sig);
	} break;

	case ev:pl3:stmt:sw: {
		var st:env nest;
		var pt:st:pl3:sw sw = stmt->data.sw;

		ctx_expr(ctx, env, sw->eval, sig);

		if(pl3:type_is_unk(sw->eval->type))
			ctx_fill(sw->eval, pl3:type_i32);
		// FIXME must be somethign reasonable

		nest = env_sw(env, sw);
		ctx_stmt(ctx, &nest, sw->stmt, sig);
	} break;

	case ev:pl3:stmt:cas: {
		var pt:st:pl3:cas cas = stmt->data.cas;

		if(env->sw == null)
			return ctx_err(ctx, "%C: Case statement not within switch.", pl3:meta_call(&stmt->meta));

		ctx_expr(ctx, env, cas->expr, sig);
		if(pl3:type_is_unk(cas->expr->type))
			ctx_fill(cas->expr, env->sw->eval->type);

		cas->next = env->sw->cas;
		env->sw->cas = cas;
	} break;

	case ev:pl3:stmt:dflt: {
		if(env->sw == null)
			return ctx_err(ctx, "%C: Default statement not within switch.", pl3:meta_call(&stmt->meta));

		if(env->sw->dflt != null)
			return ctx_err(ctx, "%C: Duplicate default statement.", pl3:meta_call(&stmt->meta));

		env->sw->dflt = stmt;
	} break;

	case ev:pl3:stmt:brk:
	case ev:pl3:stmt:cont: {
		if(stmt->data.depth > env->depth)
			return ctx_err(ctx, "%C: Cannot `%s` with depth `%u`.", pl3:meta_call(&stmt->meta), (stmt->tag == ev:pl3:stmt:brk) ? "break" : "continue", stmt->data.depth);
	} break;

	case ev:pl3:stmt:eret: {
		var pt:st:pl3:expr sub;
		var pt:st:pl3:err err;

		sub = stmt->data.expr;
		ctx_expr(ctx, env, sub, sig);

		err = pl3:type_get_err(sig->ret);
		if(err == null)
			return ctx_err(ctx, "%C: The function must return an error type to use `e:ret`.", pl3:meta_call(&sub->meta));

		if(pl3:type_is_unk(sub->type))
			ctx_fill(sub, err->fail);

		if(!chk_assign(err->fail, sub->type))
			return ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&sub->meta), pl3:type_call(&err->fail), pl3:type_call(&sub->type));
	} break;

	case ev:pl3:stmt:onerr:
		ctx_stmt(ctx, env, stmt->data.stmt, sig);
		break;

	default:
		fatal("FIXME %u", stmt->tag);
	}
};

/**
 * Typecheck an expression.
 *   @ctx: The context.
 *   @env: The environment.
 *   @expr: The expression.
 *   @sig: The current function signature.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:expr expr, pt:st:pl3:sig sig) ctx_expr = {
	ctx_type(ctx, env, expr->type, &expr->meta);

	switch(expr->tag) {
	case ev:pl3:expr:lit:
		pl3:type_replace(&expr->type, pl3:lit_type(expr->data.lit));
		break;

	case ev:pl3:expr:ident: {
		var pt:st:pl3:ident ident = expr->data.ident;

		// TODO don't hardcode builtins per platform and do real typechecking
		if(str:equal(ident->str, "bi:syscall")) {
			var u32 i;
			var pt:st:pl3:sig sig;
			var pt:pt:st:pl3:param param;

			ident->tag = ev:pl3:ident:builtin;
			pl3:type_replace(&expr->type, pl3:type_sig(sig = pl3:sig_new(pl3:type_i64, null, true)));

			param = &sig->param;
			for(i = 0; i < 7; i++) {
				*param = pl3:param_new(pl3:type_i64, null);
				param = &(*param)->next;
			}
		}
		else {
			var pt:st:name name;

			name = env_name_find(env, ident->str);
			if(name == null)
				return ctx_err(ctx, "%C: Unknown identifier '%s'.", pl3:meta_call(&expr->meta), ident->str);

			if(name->param != null) {
				pl3:ident_param(ident, name->param);
				pl3:type_replace(&expr->type, pl3:type_copy(name->param->type));
			}
			else {
				pl3:ident_link(ident, name->decl, name->bind);
				pl3:type_replace(&expr->type, pl3:type_copy(name->decl->type));
			}
		}
	} break;

	case ev:pl3:expr:op1: {
		var pt:st:pl3:op1 op1 = expr->data.op1;

		ctx_expr(ctx, env, op1->in, sig);

		switch(op1->tag) {
		case ev:pl3:op1:deref: {
			var pt:st:pl3:arr arr;

			if(pl3:type_is_ptr(op1->in->type)) {
				ctx_type(ctx, env, op1->in->type.data.ptr->type, &op1->in->meta);
				pl3:type_replace(&expr->type, pl3:type_copy(op1->in->type.data.ptr->type));
			}
			else if((arr = pl3:type_get_arr(op1->in->type)) != null)
				pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(arr->type), true)));
			else
				return ctx_err(ctx, "%C: Cannot dereference non-pointer type `%C`.", pl3:meta_call(&expr->meta), pl3:type_call(&op1->in->type));

		} break;

		case ev:pl3:op1:addr:
			pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(op1->in->type), true)));
			break;

		case ev:pl3:op1:preinc:
		case ev:pl3:op1:predec:
		case ev:pl3:op1:postinc:
		case ev:pl3:op1:postdec:
			pl3:type_replace(&expr->type, pl3:type_copy(op1->in->type));
			break;

		case ev:pl3:op1:pos:
		case ev:pl3:op1:neg:
		case ev:pl3:op1:not:
			if(!pl3:type_is_int(op1->in->type) && !pl3:type_is_unk(op1->in->type))
				return ctx_err(ctx, "%C: Cannot use arithmetic on non-numeric type '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op1->in->type));

			pl3:type_replace(&expr->type, pl3:type_copy(op1->in->type));
			break;

		case ev:pl3:op1:lnot:
			if(!pl3:type_is_bool(op1->in->type))
				return ctx_err(ctx, "%C: Logical not has non-boolean type '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op1->in->type));

			pl3:type_replace(&expr->type, pl3:type_bool);
			break;

		default:
			fatal("FIXME op1 %u", op1->tag);
		}
	} break;

	case ev:pl3:expr:op2: {
		var pt:st:pl3:op2 op2 = expr->data.op2;

		ctx_expr(ctx, env, op2->lhs, sig);
		ctx_expr(ctx, env, op2->rhs, sig);

		if(op2->tag == ev:pl3:op2:assign) {
			if(pl3:type_is_unk(op2->rhs->type))
				ctx_fill(op2->rhs, op2->lhs->type);

			if(!chk_assign(op2->lhs->type, op2->rhs->type))
				return ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op2->lhs->type), pl3:type_call(&op2->rhs->type));

			pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
		}
		else if((op2->tag == ev:pl3:op2:shr) || (op2->tag == ev:pl3:op2:shl)) {
			if(pl3:type_is_unk(op2->rhs->type))
				ctx_fill(op2->rhs, pl3:type_i32);

			if(pl3:type_is_unk(op2->lhs->type))
				ctx_fill(op2->lhs, pl3:type_i32);

			pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
		}
		else if(pl3:op2_is_cmp(op2->tag)) {
			if(pl3:type_is_unk(op2->rhs->type) && !pl3:type_is_unk(op2->lhs->type))
				ctx_fill(op2->rhs, op2->lhs->type);

			if(pl3:type_is_unk(op2->lhs->type) && !pl3:type_is_unk(op2->rhs->type))
				ctx_fill(op2->lhs, op2->rhs->type);

			if(!chk_cmp(op2->lhs->type, op2->rhs->type))
				return ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op2->lhs->type), pl3:type_call(&op2->rhs->type));

			pl3:type_replace(&expr->type, pl3:type_bool);
		}
		else {
			//FIXME this looks ugly
			if(((op2->tag == ev:pl3:op2:add) || (op2->tag == ev:pl3:op2:addeq) || (op2->tag == ev:pl3:op2:sub) || (op2->tag == ev:pl3:op2:subeq)) && (pl3:type_is_ptr(op2->lhs->type) || pl3:type_is_arr(op2->lhs->type)) && !pl3:type_is_ptr(op2->rhs->type)) {
				if(pl3:type_is_unk(op2->rhs->type))
					ctx_fill(op2->rhs, pl3:type_i32); // TODO maybe 64 bit?
			}
			else {
				if(pl3:type_is_unk(op2->rhs->type) && !pl3:type_is_unk(op2->lhs->type))
					ctx_fill(op2->rhs, op2->lhs->type);

				if(pl3:type_is_unk(op2->lhs->type) && !pl3:type_is_unk(op2->rhs->type))
					ctx_fill(op2->lhs, op2->rhs->type);

				if(!chk_same(op2->lhs->type, op2->rhs->type))
					return ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op2->lhs->type), pl3:type_call(&op2->rhs->type));

			}

			pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
		}
	} break;

	case ev:pl3:expr:index: {
		var pt:st:pl3:arr arr;
		var pt:st:pl3:index index = expr->data.index;

		ctx_expr(ctx, env, index->base, sig);
		ctx_expr(ctx, env, index->off, sig);

		if(pl3:type_is_unk(index->off->type))
			ctx_fill(index->off, pl3:type_i32);

		if(pl3:type_is_ptr(index->base->type)) {
			ctx_type(ctx, env, index->base->type.data.ptr->type, &index->base->meta);
			pl3:type_replace(&expr->type, pl3:type_copy(index->base->type.data.ptr->type));
		}
		else if((arr = pl3:type_get_arr(index->base->type)) != null) {
			ctx_type(ctx, env, arr->type, &index->base->meta);
			pl3:type_replace(&expr->type, pl3:type_copy(arr->type));
		}
		else
			return ctx_err(ctx, "%C: Expected pointer or array.", pl3:meta_call(&index->base->meta));

		if(!pl3:type_is_int(index->off->type))
			return ctx_err(ctx, "%C: Index must be an integer type.", pl3:meta_call(&index->off->meta));
	} break;

	case ev:pl3:expr:comp: {
		var pt:st:pl3:agg agg;
		var pt:st:pl3:arr arr;
		var pt:st:pl3:comp comp = expr->data.comp;
		var pt:st:pl3:list list = comp->list;

		ctx_type(ctx, env, comp->type, &expr->meta);

		if(pl3:type_is_unk(comp->type)) // FIXME this just looks ugly
			break;

		agg = pl3:type_get_agg(comp->type, null);
		if(agg != null)
			ctx_list(ctx, env, list, agg, sig);
		else if((arr = pl3:type_get_arr(comp->type)) != null)
			ctx_arr(ctx, env, list, arr, sig);
		else {
			var pt:st:pl3:expr val;

			if(list->init == null)
				return ctx_err(ctx, "%C: Invalid cast.", pl3:meta_call(&expr->meta));
			else if(list->init->next != null)
				return ctx_err(ctx, "%C: Invalid cast. Too many initializers.", pl3:meta_call(&expr->meta));
			else if(list->init->tag != ev:pl3:init:expr)
				return ctx_err(ctx, "%C: Invalid cast. Initializer must be an expression.", pl3:meta_call(&expr->meta));

			val = list->init->data.expr;
			ctx_expr(ctx, env, val, sig);
			if(pl3:type_is_comp(val->type))
				return ctx_err(ctx, "%C: Invalid cast. Source expression cannot be a compound type.", pl3:meta_call(&list->init->data.expr->meta));

			if(pl3:type_is_unk(val->type))
				ctx_fill(val, comp->type);
		}

		pl3:type_replace(&expr->type, pl3:type_copy(comp->type));
	} break;

	case ev:pl3:expr:call: {
		var st:pl3:type type;
		var pt:st:pl3:arg arg;
		var pt:st:pl3:sig sig;
		var pt:st:pl3:param param;
		var pt:st:pl3:call call = expr->data.call;

		ctx_expr(ctx, env, call->func, sig);

		type = call->func->type;
		if(call->deref) {
			var pt:st:pl3:ptr ptr;

			ptr = pl3:type_get_ptr(type);
			if(ptr == null)
				return ctx_err(ctx, "%C: Cannot dereference a non-pointer type.", pl3:meta_call(&call->func->meta));

			type = ptr->type;
		}

		sig = pl3:type_get_sig(type);
		if(sig == null)
			return ctx_err(ctx, "%C: Cannot call non-function type.", pl3:meta_call(&call->func->meta));

		ctx_sig(ctx, env, sig, &expr->meta); // TODO this doesn't seem like the right place for this
		ctx_type(ctx, env, sig->ret, &expr->meta);
		pl3:type_replace(&expr->type, pl3:type_copy(sig->ret));

		//FIXME for(arg = call->arg, param = sig->param; (arg != null) && (param != null); arg = arg->next, param = param->next) {
		arg = call->arg;
		param = sig->param;
		while((arg != null) && (param != null)) {
			ctx_expr(ctx, env, arg->expr, sig);

			if(pl3:type_is_unk(arg->expr->type))
				ctx_fill(arg->expr, param->type);

			if(!chk_assign(param->type, arg->expr->type))
				ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&arg->expr->meta), pl3:type_call(&param->type), pl3:type_call(&arg->expr->type));

			arg = arg->next;
			param = param->next;
		}

		if((param == null) && (arg != null)) {
			if(sig->vlist) {
				// TODO check thing like `io:fmt`
				while(arg != null) {
					ctx_expr(ctx, env, arg->expr, sig);

					if(pl3:type_is_unk(arg->expr->type))
						ctx_fill(arg->expr, pl3:type_i32);

					arg = arg->next;
				}
			}
			else
				return ctx_err(ctx, "%C: Too many arguments.", pl3:meta_call(&expr->meta));
		}
		else if((arg == null) && (param != null))
			return ctx_err(ctx, "%C: Not enough arguments.", pl3:meta_call(&expr->meta));
	} break;

	case ev:pl3:expr:elem: {
		var en:pl3:tydecl tag;
		var st:pl3:type type;
		var pt:st:pl3:agg agg;
		var pt:st:pl3:err err;
		var pt:st:pl3:field field;
		var pt:st:pl3:elem elem = expr->data.elem;

		ctx_expr(ctx, env, elem->expr, sig);
		type = elem->expr->type;

		if(elem->deref) {
			var pt:st:pl3:ptr ptr = pl3:type_get_ptr(type);

			if(ptr == null)
				return ctx_err(ctx, "%C: Cannot dereference a non-pointer type.", pl3:meta_call(&expr->meta));

			ctx_type(ctx, env, ptr->type, &expr->meta);
			type = ptr->type;
		}

		if((agg = pl3:type_get_agg(type, &tag)) != null) {
			field = pl3:agg_find(agg, elem->id, &type, &elem->idx);
			if(field == null)
				return ctx_err(ctx, "%C: Cannot find field '%s' in type '%C'.", pl3:meta_call(&elem->expr->meta), elem->id, pl3:type_call(&type));
			
			pl3:type_replace(&expr->type, pl3:type_copy(type));
			ctx_type(ctx, env, expr->type, &expr->meta);
		}
		else if((err = pl3:type_get_err(type)) != null) {
			if(str:equal(elem->id, "val"))
				pl3:type_replace(&expr->type, pl3:type_copy(err->suc));
			else if(str:equal(elem->id, "err"))
				pl3:type_replace(&expr->type, pl3:type_copy(err->fail));
			else
				return ctx_err(ctx, "%C: Only members 'val' and 'err' may be accessed on an error type.", pl3:meta_call(&expr->meta));
		}
		else
			return ctx_err(ctx, "%C: Member access must be on compound type.", pl3:meta_call(&elem->expr->meta));
	} break;

	case ev:pl3:expr:func: {
		var st:env nest;
		var pt:st:pl3:param param;
		var pt:st:pl3:func func = expr->data.func;

		ctx_sig(ctx, env, func->sig, &expr->meta);

		nest = env_map(ctx->unit);
		onerr env_delete(nest);

		for(param = func->sig->param; param != null; param = param->next) {
			if(param->id != null)
				env_name_param(&nest, param);
		}

		ctx_block(ctx, &nest, func->block, func->sig);
		pl3:type_replace(&expr->type, pl3:type_sig(pl3:sig_copy(func->sig)));

		env_delete(nest);
	} break;

	case ev:pl3:expr:enref: {
		var pt:char pre, name;
		var pt:st:pl3:tydecl decl;
		var pt:st:pl3:enref ref = expr->data.enref;
		var cpt:char find, id = ref->id, post;

		// TODO the whole thing below is a mess
		find = str:chr(id, ':');
		if(find == null)
			return ctx_err(ctx, "%C: Invalid enumerated type. Missing ':'.", pl3:meta_call(&expr->meta));

		var u32 len = u32{i64{find} - i64{id}};
		pre = mem:alloc(len + 1); //FIXME
		mem:copy(pre, id, len);
		pre[len] = '\0';
		name = str:fmt("en:%s", pre);
		post = find + 1;
		onerr mem:free(pre);
		onerr mem:free(name);

		decl = env_type_get(env, name);
		if(decl == null) {
			ctx_err(ctx, "%C: Unknown enumerator '%s' for value 'ev:%s'.", pl3:meta_call(&expr->meta), name, id);
			mem:free(pre); //FIXME error handling
			mem:free(name);
			return;
		}

		if(decl->tag != ev:pl3:tydecl:enum) {
			ctx_err(ctx, "%C: Internal error. Invalid type declaration found.", pl3:meta_call(&expr->meta));
			mem:free(pre); //FIXME error handling
			mem:free(name);
			return;
		}

		ref->val = pl3:enum_find(decl->data.enum, post);
		if(ref->val == null) {
			fatal("%C: Unknown value '%s' for enumerator '%s'", pl3:meta_call(&expr->meta), post, name);
			mem:free(pre); //FIXME error handling
			mem:free(name);
			return;
		}

		pl3:type_replace(&expr->type, pl3:type_name(pl3:name_new(name, decl)));
		mem:free(pre);
	} break;

	case ev:pl3:expr:eget: {
		var pt:st:pl3:expr sub;
		var pt:st:pl3:err err;

		sub = expr->data.expr;
		ctx_expr(ctx, env, sub, sig);

		err = pl3:type_get_err(sub->type);
		if(err == null)
			return ctx_err(ctx, "%C: Call to `e:get` requires an error type.", pl3:meta_call(&sub->meta));

		// FIXME : check return type to match what we e:get
		pl3:type_replace(&expr->type, pl3:type_copy(err->suc));
	} break;

	case ev:pl3:expr:ereq: {
		var pt:st:pl3:expr sub;
		var pt:st:pl3:err err;

		sub = expr->data.expr;
		ctx_expr(ctx, env, sub, sig);

		err = pl3:type_get_err(sub->type);
		if(err == null)
			return ctx_err(ctx, "%C: Call to `e:req` requires an error type.", pl3:meta_call(&sub->meta));

		pl3:type_replace(&expr->type, pl3:type_copy(err->suc));
	} break;

	case ev:pl3:expr:tern: {
		var pt:st:pl3:tern tern = expr->data.tern;

		ctx_expr(ctx, env, tern->cond, sig);
		ctx_expr(ctx, env, tern->ontrue, sig);
		ctx_expr(ctx, env, tern->onfalse, sig);

		// TODO maybe make it not need a boolean?
		if(!pl3:type_is_bool(tern->cond->type))
			ctx_err(ctx, "%C: Expected boolean.", pl3:meta_call(&tern->cond->meta));
	
		if(pl3:type_is_unk(tern->ontrue->type) && !pl3:type_is_unk(tern->onfalse->type))
			ctx_fill(tern->ontrue, tern->onfalse->type);

		if(pl3:type_is_unk(tern->onfalse->type) && !pl3:type_is_unk(tern->ontrue->type))
			ctx_fill(tern->onfalse, tern->ontrue->type);

		if(!chk_same(tern->ontrue->type, tern->onfalse->type))
			return ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&tern->ontrue->type), pl3:type_call(&tern->onfalse->type));

		pl3:type_replace(&expr->type, pl3:type_copy(tern->onfalse->type));
	} break;

	case ev:pl3:expr:size: {
		var pt:st:pl3:size size = expr->data.size;

		if(size->expr != null) {
			ctx_expr(ctx, env, size->expr, sig);

			if(pl3:type_is_unk(size->expr->type))
				return ctx_err(ctx, "%C: Cannot take sizeof unresolved type.", pl3:meta_call(&expr->meta));

			size->type = pl3:type_copy(size->expr->type);
		}

		ctx_type(ctx, env, size->type, &expr->meta);
	} break;

	case ev:pl3:expr:arrlen: {
		var pt:st:pl3:arr arr;
		var pt:st:pl3:arrlen alen = expr->data.len;

		if(alen->expr != null) {
			ctx_expr(ctx, env, alen->expr, sig);

			if(pl3:type_is_unk(alen->expr->type))
				return ctx_err(ctx, "%C: Cannot take `arrlen` of unresolved type.", pl3:meta_call(&expr->meta));

			alen->type = pl3:type_copy(alen->expr->type);
		}

		ctx_type(ctx, env, alen->type, &expr->meta);

		if((arr = pl3:type_get_arr(alen->type)) == null)
			return ctx_err(ctx, "%C: Cannot use `arrlen` on non-array type.", pl3:meta_call(&expr->meta));

		alen->val = i32{arr->len};
	} break;

	case ev:pl3:expr:offset: {
		var u32 idx;
		var pt:st:pl3:agg agg;
		var pt:st:pl3:offset offset = expr->data.offset;

		ctx_type(ctx, env, offset->type, &expr->meta);

		agg = pl3:type_get_struct(offset->type);
		if(agg == null)
			return ctx_err(ctx, "%C: Type for 'offsetof' must be a structure.", pl3:meta_call(&expr->meta));

		if(pl3:agg_find(agg, offset->id, null, &idx) == null)
			return ctx_err(ctx, "%C: Type '%C' does not have memeber '%s'.", pl3:meta_call(&expr->meta), pl3:type_call(&offset->type), offset->id);

		offset->val = i32{pl3:agg_off(agg, idx, &pl3:arch_x64)};
	} break;

	case ev:pl3:expr:parent: {
		var u32 idx;
		var st:pl3:type type;
		var pt:st:pl3:agg agg;
		var pt:st:pl3:ptr ptr;
		var pt:st:pl3:parent parent = expr->data.parent;

		ctx_expr(ctx, env, parent->expr, sig);
		ctx_type(ctx, env, parent->type, &expr->meta);

		agg = pl3:type_get_struct(parent->type);
		if(agg == null)
			return ctx_err(ctx, "%C: Type for 'getparent' must be a structure.", pl3:meta_call(&expr->meta));

		if(pl3:agg_find(agg, parent->id, &type, &idx) == null)
			return ctx_err(ctx, "%C: Type '%C' does not have memeber '%s'.", pl3:meta_call(&expr->meta), pl3:type_call(&parent->type), parent->id);

		if((ptr = pl3:type_get_ptr(parent->expr->type)) == null)
			return ctx_err(ctx, "%C: Expression for 'getparent' must be a pointer.", pl3:meta_call(&parent->expr->meta));

		if(!chk_same(ptr->type, type))
			return ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&parent->expr->meta), pl3:type_call(&parent->expr->type), pl3:type_call(&ptr->type));

		parent->off = i32{pl3:agg_off(agg, idx, &pl3:arch_x64)};
		pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(parent->type), ptr->mut)));
	} break;

	case ev:pl3:expr:vinit:
		pl3:type_replace(&expr->type, pl3:type_args);
		break;

	case ev:pl3:expr:vget: {
		var pt:st:pl3:ptr ptr;
		var pt:st:pl3:vget get = expr->data.vget;

		ctx_expr(ctx, env, get->expr, sig);
		ctx_type(ctx, env, get->type, &expr->meta);
	
		ptr = pl3:type_get_ptr(get->expr->type);
		if((ptr == null) || (pl3:type_root(ptr->type).tag != ev:pl3:type:args))
			return ctx_err(ctx, "%C: Call to `args:get` requires types `pt:ty:args` as the first parameter.", pl3:meta_call(&expr->meta));

		pl3:type_replace(&expr->type, pl3:type_copy(get->type));
	} break;

	case ev:pl3:expr:getref:
		ctx_expr(ctx, env, expr->data.expr, sig);
		pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(expr->data.expr->type), false)));
		break;

	default:
		fatal("FIXME expr %u", expr->tag);
	}
};

def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:list list, st:pl3:type type, pt:st:pl3:sig sig) ctx_init = {
	var pt:st:pl3:agg agg;
	var pt:st:pl3:arr arr;

	if((agg = pl3:type_get_agg(type, null)) != null)
		ctx_list(ctx, env, list, agg, sig);
	else if((arr = pl3:type_get_arr(type)) != null)
		ctx_arr(ctx, env, list, arr, sig);
};

def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:list list, pt:st:pl3:arr arr, pt:st:pl3:sig sig) ctx_arr = {
	var pt:st:pl3:init init;
	var i32 idx = 0;

	for(init = list->init; init != null; init = init->next) {
		if(init->id != null)
			return ctx_err(ctx, "%C: Cannot have named initializers for arrays.", pl3:meta_call(&init->meta));

		init->idx = idx++;
		init->type = arr->type;

		switch(init->tag) {
		case ev:pl3:init:expr: {
			ctx_expr(ctx, env, init->data.expr, sig);

			if(pl3:type_is_unk(init->data.expr->type))
				ctx_fill(init->data.expr, arr->type);

			if(!chk_assign(arr->type, init->data.expr->type))
				return ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&init->meta), pl3:type_call(&arr->type), pl3:type_call(&init->data.expr->type));
		} break;

		case ev:pl3:init:nest:
			ctx_init(ctx, env, init->data.list, arr->type, sig);
		}
	}
};

/**
 * Typecheck an initializer list.
 *   @ctx: The context.
 *   @env: The environment.
 *   @list: The initializer list.
 *   @agg: The aggregate type.
 *   @sig: The function signature.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:list list, pt:st:pl3:agg agg, pt:st:pl3:sig sig) ctx_list = {
	var pt:bool set;
	var pt:st:pl3:init init;
	var u32 idx = 0, cnt = pl3:agg_cnt(agg);

	set = mem:alloc(cnt);
	onerr mem:free(set);

	mem:zero(set, cnt);

	for(init = list->init; init != null; init = init->next) {
		var st:pl3:type type;

		//FIXME don't double set a value
		if(init->id != null) {
			if(pl3:agg_find(agg, init->id, &type, &idx) == null) {
				mem:free(set); //TODO
				return ctx_err(ctx, "%C: Unknown field '%s'.", pl3:meta_call(&init->meta), init->id);
			}
		}
		else if(pl3:agg_get(agg, idx, &type) == null) {
			mem:free(set); //TODO
			return ctx_err(ctx, "%C: Too many initializers.", pl3:meta_call(&init->meta));
		}

		init->idx = i32{idx};
		init->type = type;

		switch(init->tag) {
		case ev:pl3:init:expr: {
			var pt:st:pl3:expr expr = init->data.expr;

			ctx_expr(ctx, env, expr, sig);
			if(pl3:type_is_unk(expr->type))
				ctx_fill(expr, type);

			if(!chk_assign(type, expr->type))
				ctx_err(ctx, "%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&init->meta), pl3:type_call(&type), pl3:type_call(&init->data.expr->type));
		} break;

		case ev:pl3:init:nest: {
			var pt:st:pl3:agg agg;

			if((agg = pl3:type_get_agg(type, null)) == null) {
				mem:free(set); //TODO
				return ctx_err(ctx, "%C: Invalid initializer.", pl3:meta_call(&init->meta));
			}

			ctx_list(ctx, env, init->data.list, agg, sig);
		} break;
		}

		set[idx++] = true;
	}

	if(!list->dots) {
		for(idx = 0; idx < cnt; idx++) {
			if(!set[idx] && false) { //FIXME
				mem:free(set); //TODO
				return ctx_err(ctx, "%C: Missing initializer(s).", pl3:meta_call(&list->meta));
			}
		}
	}

	mem:free(set);
};

def bool(st:pl3:type lhs, st:pl3:type rhs) chk_cmp = {
	for() {
		if(lhs.tag != rhs.tag)
			return false;

		lhs = pl3:type_root(lhs);
		rhs = pl3:type_root(rhs);

		if(lhs.tag == ev:pl3:type:ptr) {
			lhs = lhs.data.ptr->type;
			rhs = rhs.data.ptr->type;

			if(pl3:type_is_void(lhs) || pl3:type_is_void(rhs))
				return true;
		}
		else if(lhs.tag == ev:pl3:type:sig) {
			fatal("stub");
		}
		//else if(lhs.tag == ev:pl3:type:comp || lhs.tag == el_union_v) {
		//}
		else
			return true;
	}
};

def bool(st:pl3:type lhs, st:pl3:type rhs) chk_same = {
	for() {
		if(lhs.tag != rhs.tag)
			return false;

		lhs = pl3:type_root(lhs);
		rhs = pl3:type_root(rhs);

		if(lhs.tag == ev:pl3:type:ptr) {
			if(lhs.data.ptr->mut != rhs.data.ptr->mut)
				return false;

			lhs = lhs.data.ptr->type;
			rhs = rhs.data.ptr->type;

			if(pl3:type_is_void(lhs) || pl3:type_is_void(rhs))
				return true;
		}
		else if(lhs.tag == ev:pl3:type:sig) {
			fatal("stub");
		}
		//else if(lhs.tag == ev:pl3:type:comp || lhs.tag == el_union_v) {
		//}
		else
			return true;
	}
};
/*
		if(lhs.kind == el_ptr_v) {
			if((lhs.data.ptr->flags & EL_CONST) != (rhs.data.ptr->flags & EL_CONST))
				return false;

			lhs = lhs.data.ptr->sub;
			rhs = rhs.data.ptr->sub;

			if((lhs.kind == el_void_v) || (rhs.kind == el_void_v))
				break;
		}
		else if(lhs.kind == el_struct_v || lhs.kind == el_union_v) {
			if(strcmp(lhs.data.vstruct->id, rhs.data.vstruct->id) != 0)
				return false;

			break;
		}
		else if(lhs.kind == el_alias_v) {
			if(strcmp(lhs.data.alias->id, rhs.data.alias->id) != 0)
				return false;

			break;
		}
		else
			break;
	}

	return true;
}
*/

def[export] st:pl3:type(st:pl3:type type) chk_root = {
	var pt:st:pl3:name name;

	for() {
		if(type.tag != ev:pl3:type:name)
			return type;

		name = type.data.name;
		if(name->decl == null)
			return type;

		if(name->decl->tag != ev:pl3:tydecl:alias)
			return type;

		type = name->decl->data.alias->type;
	}
};

def bool(st:pl3:type lhs, st:pl3:type rhs) chk_assign = {
	var bool strict = false;
	var st:pl3:type l = lhs, r = rhs;

	for() {
		lhs = chk_root(lhs);
		rhs = chk_root(rhs);

		if(lhs.tag != rhs.tag)
			return false;

		if(lhs.tag == ev:pl3:type:ptr) {
			if(lhs.data.ptr->mut && !rhs.data.ptr->mut)
				return false;
			else if(strict && rhs.data.ptr->mut)
				return false;

			strict |= !rhs.data.ptr->mut;

			lhs = lhs.data.ptr->type;
			rhs = rhs.data.ptr->type;
			if(pl3:type_is_void(lhs) || pl3:type_is_void(rhs))
				break;
		}
		else if(lhs.tag == ev:pl3:type:sig) {
			var pt:st:pl3:param lparam = lhs.data.sig->param, rparam = rhs.data.sig->param;

			if(!chk_assign(lhs.data.sig->ret, rhs.data.sig->ret))
				return false;

			for(;;) {
				if((lparam == null) && (rparam == null))
					break;
				else if((lparam == null) || (rparam == null))
					return false;

				if(!chk_assign(rparam->type, lparam->type))
					return false;

				lparam = lparam->next;
				rparam = rparam->next;
			}

			return lhs.data.sig->vlist == rhs.data.sig->vlist;
		}
		//else if(lhs.tag == ev:pl3:type:comp || lhs.tag == el_union_v) {
		//}
		else
			break;
/*
		if(lhs.kind == el_ptr_v) {
			if(!(lhs.data.ptr->flags & EL_CONST) && (rhs.data.ptr->flags & EL_CONST))
				return false;
			else if(strict && !(rhs.data.ptr->flags & EL_CONST))
				return false;

			strict |= rhs.data.ptr->flags & EL_CONST;
			lhs = lhs.data.ptr->sub;
			rhs = rhs.data.ptr->sub;

			if((lhs.kind == el_void_v) || (rhs.kind == el_void_v))
				break;
		}
		else if(lhs.kind == el_func_v) {
			uint32_t i;

			if(!chk_assign(lhs.data.func->ret, rhs.data.func->ret))
				return false;

			if(lhs.data.func->cnt != rhs.data.func->cnt)
				return false;

			for(i = 0; i < lhs.data.func->cnt; i++) {
				if(!chk_assign(rhs.data.func->param[i].type, lhs.data.func->param[i].type))
					return false;
			}

			break;
		}
		else if(lhs.kind == el_struct_v || lhs.kind == el_union_v) {
			if(strcmp(lhs.data.vstruct->id, rhs.data.vstruct->id) != 0)
				return false;

			break;
		}
		else
			break;
	*/
	}

	return true;
};

/**
 * Check a function signature.
 *   @env: The environment.
 *   @sig: The function signature.
 *   @meta: The metadata.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:sig sig, pt:st:pl3:meta meta) ctx_sig = {
	var pt:st:pl3:param param;

	ctx_type(ctx, env, sig->ret, meta);

	for(param = sig->param; param != null; param = param->next)
		ctx_type(ctx, env, param->type, meta);
};

def void(pt:st:ctx ctx, pt:st:env env, st:pl3:type type, pt:st:pl3:meta meta, bool err) ctx_type2 = {
	if(type.tag == ev:pl3:type:name) {
		var pt:st:pl3:tydecl decl;
		var pt:st:pl3:name name = type.data.name;

		decl = env_type_get(env, name->id);
		if(decl == null)
			return ctx_err(ctx, "%C: Unknown type '%s'.", pl3:meta_call(meta), name->id);

		name->decl = decl;
	}

	switch(type.tag) {
		fatal("FIXME stub");
		break;

	case ev:pl3:type:name:
		break;

	case ev:pl3:type:ptr:
		ctx_type(ctx, env, type.data.ptr->type, meta);
		break;

	case ev:pl3:type:arr:
		ctx_type(ctx, env, type.data.arr->type, meta);
		break;

	case ev:pl3:type:sig:
		ctx_sig(ctx, env, type.data.sig, meta);
		break;

	case ev:pl3:type:err:
		ctx_type(ctx, env, type.data.err->suc, meta);
		ctx_type(ctx, env, type.data.err->fail, meta);
		break;

	default:
		break;
	}
};
def void(pt:st:ctx ctx, pt:st:env env, st:pl3:type type, pt:st:pl3:meta meta) ctx_type = {
	ctx_type2(ctx, env, type, meta, true);
};


// FIXME where does this go??? is it needed?
def void(pt:st:env env, pt:st:pl3:memb memb, u16 depth) ctx_memb = {
	var en:pl3:tydecl tag;
	var pt:st:pl3:agg agg;

	//if(depth == m:u16:max) // FIXME: this

	agg = pl3:type_get_agg(memb->type, &tag);
	if(agg != null) {
		var pt:st:pl3:memb iter;

		for(iter = agg->memb; iter != null; iter = iter->next)
			ctx_memb(env, iter, depth + 1);
	}
};

/**
 * Typecheck an aggregate type.
 *   @ctx: The context.
 *   @env: The environment.
 *   @agg: The aggregate type.
 *   @meta: The metadata.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:agg agg, pt:st:pl3:meta meta) ctx_agg = {
	var pt:st:pl3:memb memb;

	for(memb = agg->memb; memb != null; memb = memb->next) {
		ctx_type(ctx, env, memb->type, meta);
		ctx_memb(env, memb, 0);
	}
};

/**
 * Typecheck a type declaration.
 *   @ctx: The context.
 *   @env: The environment.
 *   @decl: The type declaration.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:tydecl decl) ctx_tydecl = {
	switch(decl->tag) {
	case ev:pl3:tydecl:alias:
		ctx_type(ctx, env, decl->data.alias->type, &decl->meta);
		break;

	case ev:pl3:tydecl:struct:
	case ev:pl3:tydecl:union:
		ctx_agg(ctx, env, decl->data.agg, &decl->meta);
		break;

	case ev:pl3:tydecl:enum:
		ctx_enum(ctx, env, decl->data.enum, decl, &decl->meta);
		break;
	}
};

/**
 * Typecheck an enumerator.
 *   @ctx: The context.
 *   @env: The environment.
 *   @enum: The enumerator type.
 *   @meta: The metadata.
 */
def void(pt:st:ctx ctx, pt:st:env env, pt:st:pl3:enum enum, pt:st:pl3:tydecl decl, pt:st:pl3:meta meta) ctx_enum = {
	var pt:st:pl3:enval val, iter, prev = null;

	for(val = enum->val; val != null; val = val->next) {
		for(iter = enum->val; iter != val; iter = iter->next) {
			if(str:equal(iter->id, val->id))
				return ctx_err(ctx, "%C: Duplicate value '%s'.", pl3:meta_call(meta), val->id); // FIXME wrong meta
		}

		if(val->expr == null) {
			if(prev == null)
				// FIXME wrong meta below
				val->expr = pl3:expr_lit(pl3:lit_int(m:int_zero()), pl3:meta_copy(*meta));
			else {
				// FIXME so ugly
				var pt:char str = str:fmt("%s:%s", decl->id + 3, prev->id);

				// FIXME wrong meta below
				val->expr = pl3:expr_op2(
					pl3:op2_add(
						pl3:expr_enref(pl3:enref_new(str), pl3:meta_copy(*meta)),
						pl3:expr_lit(pl3:lit_int(m:int_one()), pl3:meta_copy(*meta))
					), pl3:meta_copy(*meta));
			}
		}

		var pt:st:pl3:sig sig; // TODO ugly
		sig = pl3:sig_new(pl3:type_void, null, false);

		ctx_expr(ctx, env, val->expr, sig);
		if(pl3:type_is_unk(val->expr->type)) {
			var st:pl3:type type = pl3:type_name(pl3:name_new(str:dup(decl->id), decl)); //FIXME ugly
			ctx_fill(val->expr, type); //FIXME wrong type
			pl3:type_delete(type);
		}

		pl3:sig_delete(sig);
		prev = val;
	}
};


/**
 * Perform a typefilll on an expression.
 *   @expr: The expression.
 *   @type: The type to fill.
 */
def void(pt:st:pl3:expr expr, st:pl3:type type) ctx_fill = {
	if(pl3:type_is_unk(type) || !pl3:type_is_unk(expr->type))
	//if(pl3:type_is_unk(type)) FIXME check if correct
		return;

	switch(expr->tag) {
	case ev:pl3:expr:lit:
		pl3:lit_fill(expr->data.lit, type);
		pl3:type_replace(&expr->type, pl3:type_copy(type)); //FIXME is this okay?
		break;

	case ev:pl3:expr:ident:
	case ev:pl3:expr:size:
	case ev:pl3:expr:arrlen:
	case ev:pl3:expr:offset:
		pl3:type_replace(&expr->type, pl3:type_copy(type));
		break;

	case ev:pl3:expr:tern: {
		var pt:st:pl3:tern tern = expr->data.tern;

		ctx_fill(tern->ontrue, type);
		ctx_fill(tern->onfalse, type);
		pl3:type_replace(&expr->type, pl3:type_copy(tern->ontrue->type));
	} break;

	case ev:pl3:expr:op1:
		ctx_fill(expr->data.op1->in, type);
		pl3:type_replace(&expr->type, pl3:type_copy(expr->data.op1->in->type));
		break;

	case ev:pl3:expr:op2: {
		var pt:st:pl3:op2 op2 = expr->data.op2;

		ctx_fill(op2->lhs, type);
		ctx_fill(op2->rhs, type);
		pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
	} break;

	case ev:pl3:expr:func:
	case ev:pl3:expr:comp:
	case ev:pl3:expr:elem:
	case ev:pl3:expr:call:
	case ev:pl3:expr:enref:
	case ev:pl3:expr:eget:
	case ev:pl3:expr:ereq:
	case ev:pl3:expr:index:
	case ev:pl3:expr:parent:
		break;

	default:
		fatal("FIXME this %d", expr->tag);
	}
};


/**
 * Create an error and add it to the context.
 *   @ctx: The context.
 */
def void(pt:st:ctx ctx, cpt:char fmt, ...) ctx_err = {
	var ty:args args = args:init();

	*ctx->diag = mem:make(st:pl3:diag{ str:fmtv(fmt, args), null });
	ctx->diag = &(*ctx->diag)->next;
};


/**
 * Create the top level environment.
 *   &returns: The environment.
 */
def st:env() env_top = {
	return st:env{ mem:make(st:map{ avl:root_new(&avl:cmp_str), avl:root_new(&avl:cmp_str), null }), null, 0 };
};

/**
 * Create an environment with a new map.
 *   @env: The parent environment.
 *   &returns: The next environment.
 */
def st:env(pt:st:env env) env_map = {
	return st:env{ mem:make(st:map{ avl:root_new(&avl:cmp_str), avl:root_new(&avl:cmp_str), env->map }), env->sw, env->depth };
};

/**
 * Create an environment.
 *   @env: The parent environment.
 *   @sw: The switch.
 *   &reurns: THe new environment.
 */
def st:env(pt:st:env env, pt:st:pl3:sw sw) env_sw = {
	return st:env{ env->map, sw, env->depth + 1 };
};

/**
 * Delete an environment.
 *   @env: The environment.
 */
def void(st:env env) env_delete = {
	if(env.map != env.map->up) {
		avl:root_delete(&env.map->names, offsetof(st:name, node), &mem:free);
		avl:root_delete(&env.map->types, offsetof(st:type, node), &mem:free);
		mem:free(env.map);
	}
};


/**
 * Add a variable to the environment.
 *   @env: The environment.
 *   @param: The parameter.
 *   @decl: The declarations.
 *   @bind: The binding.
 */
def void(pt:st:env env, pt:st:pl3:param param, pt:st:pl3:decl decl, pt:st:pl3:bind bind) env_name_add = {
	var pt:st:name name;

	name = mem:make(st:name{ param, decl, bind, avl:node((param != null) ? param->id : bind->id) });
	avl:root_add(&env->map->names, &name->node);
};

/**
 * Add a binding to the environment.
 *   @env: The environment.
 *   @decl: The declaration.
 *   @bind: The binding.
 */
def void(pt:st:env env, pt:st:pl3:decl decl, pt:st:pl3:bind bind) env_name_bind = {
	env_name_add(env, null, decl, bind);
};

/**
 * Add a parameter to the environment.
 *   @env: The environment.
 *   @decl: The declaration.
 *   @bind: The binding.
 */
def void(pt:st:env env, pt:st:pl3:param param) env_name_param = {
	env_name_add(env, param, null, null);
};

/**
 * Find a variable given its identifier.
 *   @env: The environment.
 *   @id: The identifier.
 *   &returns: The declaration if found, null otherwise.
 */
def pt:st:name(pt:st:env env, cpt:char id) env_name_find = {
	var pt:st:avl:node node;
	var pt:st:map map = env->map;

	while(map != null) {
		node = avl:root_get(&map->names, id);
		if(node != null)
			return getparent(node, st:name, node);

		map = map->up;
	}

	return null;
};

/**
 * Add a type to the environment.
 *   @env: The environment.
 *   @decl: The type declarations.
 */
def void(pt:st:env env, pt:st:pl3:tydecl decl) env_type_add = {
	var pt:st:type type;

	switch(decl->tag) {
	case ev:pl3:tydecl:alias:
		type = mem:make(st:type{ decl, avl:node(decl->id) });
		break;

	case ev:pl3:tydecl:struct:
	case ev:pl3:tydecl:union:
		type = mem:make(st:type{ decl, avl:node(decl->data.agg->id) });
		break;

	case ev:pl3:tydecl:enum:
		type = mem:make(st:type{ decl, avl:node(decl->id) });
		break;
	}

	avl:root_add(&env->map->types, &type->node);
};

/**
 * Retrieve a type from the environment.
 *   @env: The environment.
 *   @id: The type identifier.
 *   &returns: The type declaration if found, null otherwise.
 */
def pt:st:pl3:tydecl(pt:st:env env, cpt:char id) env_type_get = {
	var pt:st:avl:node node;
	var pt:st:map map = env->map;

	while(map != null) {
		node = avl:root_get(&map->types, id);
		if(node != null)
			return getparent(node, st:type, node)->decl;

		map = map->up;
	}

	return null;
};


/**
 * Delete a list of diagnostics.
 *   @diag: The diagnostic list.
 */
def[export] void(pt:st:pl3:diag diag) pl3:diag_delete = {
	var pt:st:pl3:diag iter;

	while(diag != null) {
		diag = (iter = diag)->next;
		mem:free(iter->str);
		mem:free(iter);
	}
};
