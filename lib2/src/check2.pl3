/**
 * Environment structure.
 */
tydef en:env { func, block, sw, loop };
tydef un:env { pt:st:map map; pt:st:pl3:sw sw; };
tydef st:env {
	u32 ptr; /// Pointer size.

	en:env tag;  /// Type tag
	un:env data; /// Data union

	pt:st:env up; /// The parent environment
};

/**
 * Symbol and type mappping structure.
 */
tydef st:map {
	st:avl:root sym, type; /// The tree of symbols and types
};

/**
 * Symbol structure.
 */
tydef en:sym { param, ref };
tydef un:sym { pt:st:pl3:param param; st:ref ref; };
tydef st:sym {
	en:sym tag;       /// The tag (param vs reference)
	u32 p; //FIXME this shouldn't be needed, offset isn't calculated correctly
	un:sym data;      /// The data
	st:avl:node node; /// The tree node
};

/**
 * Determine if a symbol is mutable.
 *   @sym: The symbol.
 *   &returns: True if mutable (either local or global mapping).
 */
def bool(pt:st:sym sym) sym_mut = {
	switch(sym->tag) {
	case ev:sym:param:
		return true;
	
	case ev:sym:ref:
		return (sym->data.ref.decl->flags & pl3:decl:mut) != 0;
	}
};

/**
 * Determine if a symbol is external.
 *   @sym: The symbol.
 *   &returns: True if mutable (either local or global mapping).
 */
def bool(pt:st:sym sym) sym_ext = {
	switch(sym->tag) {
	case ev:sym:param:
		return false;
	
	case ev:sym:ref:
		return (sym->data.ref.decl->flags & pl3:decl:ext) != 0;
	}
};

/**
 * Variable reference structure.
 */
tydef st:ref {
	pt:st:pl3:decl decl; /// The declaration.
	pt:st:pl3:bind bind; /// The binding.
};

/**
 * Type declaration structure.
 */
tydef st:type {
	pt:st:pl3:tydecl decl; /// The declaration.
	st:avl:node node;      /// The tree node.
};


/**
 * Typecheck starting from a top-level.
 *   @top: The top-level.
 *   @ptr: The pointer size in bytes.
 */
def[export] e:str[void](pt:st:pl3:top top, u32 ptr) pl3:check2 = {
	var st:env exp;
	var pt:st:pl3:unit unit;
	var pt:st:pl3:stmt stmt;

	exp = env_top(ptr);
	onerr env_done(exp);

	for(unit = top->unit; unit != null; unit = unit->next) {
		for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
			switch(stmt->tag) {
			case ev:pl3:stmt:decl: {
				var pt:st:pl3:decl decl = stmt->data.decl;

				decl = stmt->data.decl;
				if((decl->flags & pl3:decl:pub) != 0)
					e:get(add_decl(&exp, decl));
			} break;

			case ev:pl3:stmt:tydecl: {
				var pt:st:pl3:tydecl decl = stmt->data.tydecl;

				decl = stmt->data.tydecl;
				if((decl->flags & pl3:decl:pub) != 0)
					e:get(add_type(&exp, decl));
			} break;
			}
		}
	}

	for(unit = top->unit; unit != null; unit = unit->next) {
		for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
		/*
			var pt:st:pl3:tydecl decl = stmt->data.tydecl;

			if(stmt->tag != ev:pl3:stmt:tydecl)
				continue;

			decl = stmt->data.tydecl;
			if((decl->flags & pl3:decl:pub) != 0)
				e:get(chk_tydecl(&exp, decl, null));
				*/
			switch(stmt->tag) {
			case ev:pl3:stmt:decl: {
				var pt:st:pl3:decl decl = stmt->data.decl;

				decl = stmt->data.decl;
				if((decl->flags & pl3:decl:pub) != 0)
					e:get(chk_type(&exp, decl->type, &decl->meta));
			} break;

			case ev:pl3:stmt:tydecl: {
				var pt:st:pl3:tydecl decl = stmt->data.tydecl;

				decl = stmt->data.tydecl;
				if((decl->flags & pl3:decl:pub) != 0)
					e:get(chk_tydecl(&exp, decl, null));
			} break;
			}
		}
	}

	for(unit = top->unit; unit != null; unit = unit->next)
		e:get(chk_unit(&exp, unit));

	env_done(exp);
};

/**
 * Typecheck a statement.
 *   @env: The environment.
 *   @unit: The code unit.
 */
def e:str[void](pt:st:env env, pt:st:pl3:unit unit) chk_unit = {
	var st:env nest;
	var pt:st:pl3:stmt stmt;

	nest = env_block(env);
	onerr env_done(nest);

	for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
		switch(stmt->tag) {
		case ev:pl3:stmt:decl: {
			var pt:st:pl3:decl decl = stmt->data.decl;

			decl = stmt->data.decl;
			if((decl->flags & pl3:decl:pub) == 0)
				e:get(add_decl(&nest, decl));
		} break;

		case ev:pl3:stmt:tydecl: {
			var pt:st:pl3:tydecl decl = stmt->data.tydecl;

			decl = stmt->data.tydecl;
			if((decl->flags & pl3:decl:pub) == 0)
				e:get(add_type(&nest, decl));
		} break;
		}
	}

	for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
		var pt:st:pl3:tydecl decl;

		if(stmt->tag != ev:pl3:stmt:tydecl)
			continue;

		decl = stmt->data.tydecl;
		if((decl->flags & pl3:decl:pub) == 0)
			e:get(chk_tydecl(&nest, decl, null));
	}

	for(stmt = unit->stmt; stmt != null; stmt = stmt->next) {
		if(stmt->tag != ev:pl3:stmt:decl)
			continue;

		e:get(chk_decl(&nest, stmt->data.decl, null));
	}

	env_done(nest);
};

/**
 * Typecheck a declaration.
 *   @env: The environment.
 *   @decl: The declaration.
 *   @sig: Optional. The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:decl decl, pt:st:pl3:sig sig) chk_decl = {
	var pt:st:pl3:bind bind;
	var pt:st:pl3:arr arr;

	e:get(chk_type(env, decl->type, &decl->meta));

	for(bind = decl->bind; bind != null; bind = bind->next) {
		if((arr = pl3:type_get_arr(decl->type)) != null) {
			if(arr->len == 0) {
				if(bind->expr == null)
					e:fmt("%C: Variable length array must have compound initializer.", pl3:meta_call(&decl->meta));
				else if(bind->expr->tag != ev:pl3:expr:comp)
					e:fmt("%C: Variable length array must have compound initializer.", pl3:meta_call(&decl->meta));

				arr->len = pl3:list_len(bind->expr->data.comp->list);
				pl3:type_replace(&bind->expr->data.comp->type, pl3:type_copy(decl->type));
			}
		}

		if(bind->expr == null)
			continue;

		e:get(chk_expr(env, bind->expr, sig));

		if(bind->expr->type.tag == ev:pl3:type:unk)
			e:get(chk_fill(bind->expr, decl->type));

		if(!chk_assign(decl->type, bind->expr->type))
			e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&bind->expr->meta), pl3:type_call(&decl->type), pl3:type_call(&bind->expr->type));
	}
};


/**
 * Typecheck an expression.
 *   @env: The environment.
 *   @expr: The expression.
 *   @sig: The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:expr expr, pt:st:pl3:sig sig) chk_expr = {
	switch(expr->tag) {
	case ev:pl3:expr:lit:
		pl3:type_replace(&expr->type, pl3:lit_type(expr->data.lit));
		break;

	case ev:pl3:expr:ident: {
		var pt:st:sym sym;
		var pt:st:pl3:ident ident = expr->data.ident;

		sym = get_sym(env, ident->str);
		if(sym == null)
			e:fmt("%C: Unknown identifier '%s'.", pl3:meta_call(&expr->meta), ident->str);

		switch(sym->tag) {
		case ev:sym:param:
			pl3:ident_param(ident, sym->data.param);
			pl3:type_replace(&expr->type, pl3:type_copy(sym->data.param->type));
			break;

		case ev:sym:ref:
			pl3:ident_link(ident, sym->data.ref.decl, sym->data.ref.bind);
			pl3:type_replace(&expr->type, pl3:type_copy(sym->data.ref.decl->type));
			break;
		}
	} break;

	case ev:pl3:expr:op1: {
		var pt:st:pl3:op1 op1 = expr->data.op1;

		e:get(chk_expr(env, op1->in, sig));

		switch(op1->tag) {
		case ev:pl3:op1:pos:
		case ev:pl3:op1:neg:
		case ev:pl3:op1:not:
			if(!pl3:type_is_int(op1->in->type) && !pl3:type_is_fp(op1->in->type) && !pl3:type_is_unk(op1->in->type))
				e:fmt("%C: Cannot use arithmetic on non-numeric type '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op1->in->type));

			pl3:type_replace(&expr->type, pl3:type_copy(op1->in->type));
			break;

		case ev:pl3:op1:lnot:
			if(!pl3:type_is_bool(op1->in->type))
				e:fmt("%C: Logical not has non-boolean type '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op1->in->type));

			pl3:type_replace(&expr->type, pl3:type_bool);
			break;

		case ev:pl3:op1:preinc:
		case ev:pl3:op1:predec:
		case ev:pl3:op1:postinc:
		case ev:pl3:op1:postdec:
			pl3:type_replace(&expr->type, pl3:type_copy(op1->in->type));
			break;

		case ev:pl3:op1:deref: {
			var pt:st:pl3:arr arr;

			if(pl3:type_is_ptr(op1->in->type)) {
				e:get(chk_type(env, op1->in->type.data.ptr->type, &op1->in->meta));
				pl3:type_replace(&expr->type, pl3:type_copy(op1->in->type.data.ptr->type));
			}
			else if((arr = pl3:type_get_arr(op1->in->type)) != null)
				pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(arr->type), true)));
			else
				e:fmt("%C: Cannot dereference non-pointer type `%C`.", pl3:meta_call(&expr->meta), pl3:type_call(&op1->in->type));
		} break;

		case ev:pl3:op1:addr:
			pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(op1->in->type), true)));
			break;

		default:
			fatal("FIXME op1 %u", op1->tag);
		}
	} break;

	case ev:pl3:expr:op2: {
		var pt:st:pl3:op2 op2 = expr->data.op2;

		e:get(chk_expr(env, op2->lhs, sig));
		e:get(chk_expr(env, op2->rhs, sig));

		if(op2->tag == ev:pl3:op2:assign) {
			if(pl3:type_is_unk(op2->lhs->type))
				e:fmt("%C: Assignment to an unknown type.", pl3:meta_call(&op2->lhs->meta));

			if(pl3:type_is_unk(op2->rhs->type))
				e:get(chk_fill(op2->rhs, op2->lhs->type));

			if(!chk_assign(op2->lhs->type, op2->rhs->type))
				e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op2->lhs->type), pl3:type_call(&op2->rhs->type));

			pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
		}
		else if((op2->tag == ev:pl3:op2:shr) || (op2->tag == ev:pl3:op2:shl) || (op2->tag == ev:pl3:op2:shreq) || (op2->tag == ev:pl3:op2:shleq)) {
			if(pl3:type_is_unk(op2->rhs->type))
				e:get(chk_fill(op2->rhs, pl3:type_i32));

			pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
		}
		else if(pl3:op2_is_cmp(op2->tag)) {
			if(pl3:type_is_unk(op2->rhs->type) && !pl3:type_is_unk(op2->lhs->type))
				e:get(chk_fill(op2->rhs, op2->lhs->type));

			if(pl3:type_is_unk(op2->lhs->type) && !pl3:type_is_unk(op2->rhs->type))
				e:get(chk_fill(op2->lhs, op2->rhs->type));

			if(!chk_cmp(op2->lhs->type, op2->rhs->type))
				e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op2->lhs->type), pl3:type_call(&op2->rhs->type));

			pl3:type_replace(&expr->type, pl3:type_bool);
		}
		else if(op2->tag != ev:pl3:op2:comma) {
			if(pl3:op2_is_modptr(op2)) {
				if(pl3:type_is_unk(op2->rhs->type))
					e:get(chk_fill(op2->rhs, pl3:type_i32));

				if(!pl3:type_is_int(op2->rhs->type))
					e:fmt("%C: Right-hand side of pointer arithmetic must be an integer.", pl3:meta_call(&expr->meta));
			}
			else {
				if(pl3:type_is_unk(op2->rhs->type) && !pl3:type_is_unk(op2->lhs->type))
					e:get(chk_fill(op2->rhs, op2->lhs->type));

				if(pl3:type_is_unk(op2->lhs->type) && !pl3:type_is_unk(op2->rhs->type))
					e:get(chk_fill(op2->lhs, op2->rhs->type));

				if(!chk_same(op2->lhs->type, op2->rhs->type))
					e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&op2->lhs->type), pl3:type_call(&op2->rhs->type));

			}

			pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
		}
	} break;

	case ev:pl3:expr:index: {
		var pt:st:pl3:arr arr;
		var pt:st:pl3:index index = expr->data.index;

		e:get(chk_expr(env, index->base, sig));
		e:get(chk_expr(env, index->off, sig));

		if(pl3:type_is_unk(index->off->type))
			e:get(chk_fill(index->off, pl3:type_i32));

		if(pl3:type_is_ptr(index->base->type)) {
			e:get(chk_type(env, index->base->type.data.ptr->type, &index->base->meta));
			pl3:type_replace(&expr->type, pl3:type_copy(index->base->type.data.ptr->type));
		}
		else if((arr = pl3:type_get_arr(index->base->type)) != null) {
			e:get(chk_type(env, arr->type, &index->base->meta));
			pl3:type_replace(&expr->type, pl3:type_copy(arr->type));
		}
		else
			e:fmt("%C: Expected pointer or array.", pl3:meta_call(&index->base->meta));

		if(!pl3:type_is_int(index->off->type))
			e:fmt("%C: Index must be an integer type.", pl3:meta_call(&index->off->meta));
	} break;

	case ev:pl3:expr:comp: {
		var pt:st:pl3:agg agg;
		var pt:st:pl3:arr arr;
		var pt:st:pl3:expr cast;
		var pt:st:pl3:comp comp = expr->data.comp;
		var pt:st:pl3:list list = comp->list;

		e:get(chk_type(env, comp->type, &expr->meta));
		if(pl3:type_is_unk(comp->type))
			e:fmt("%C: Unknown type.", pl3:meta_call(&expr->meta));

		if((agg = pl3:type_get_agg(comp->type, null)) != null)
			e:get(chk_list(env, list, agg, sig));
		else if((arr = pl3:type_get_arr(comp->type)) != null)
			e:get(chk_arr(env, list, arr, sig));
		else if((cast = pl3:list_cast(list)) != null)
			e:get(chk_cast(env, cast, comp->type, sig));
		else
			e:fmt("%C: Invalid cast.", pl3:meta_call(&expr->meta));

		pl3:type_replace(&expr->type, pl3:type_copy(comp->type));
	} break;

	case ev:pl3:expr:call: {
		var st:pl3:type type;
		var pt:st:pl3:arg arg;
		var pt:st:pl3:sig sig;
		var pt:st:pl3:param param;
		var pt:st:pl3:call call = expr->data.call;

		e:get(chk_expr(env, call->func, sig));

		type = call->func->type;
		if(call->deref) {
			var pt:st:pl3:ptr ptr;

			ptr = pl3:type_get_ptr(type);
			if(ptr == null)
				e:fmt("%C: Cannot dereference a non-pointer type.", pl3:meta_call(&call->func->meta));

			type = ptr->type;
		}

		sig = pl3:type_get_sig(type);
		if(sig == null)
			e:fmt("%C: Cannot call non-function type.", pl3:meta_call(&call->func->meta));

		e:get(chk_sig(env, sig, &expr->meta));
		pl3:type_replace(&expr->type, pl3:type_copy(sig->ret));

		//FIXME for(arg = call->arg, param = sig->param; (arg != null) && (param != null); arg = arg->next, param = param->next) {
		arg = call->arg;
		param = sig->param;
		while((arg != null) && (param != null)) {
			e:get(chk_expr(env, arg->expr, sig));

			if(pl3:type_is_unk(arg->expr->type))
				e:get(chk_fill(arg->expr, param->type));

			if(!chk_assign(param->type, arg->expr->type))
				e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&arg->expr->meta), pl3:type_call(&param->type), pl3:type_call(&arg->expr->type));

			arg = arg->next;
			param = param->next;
		}

		if((param == null) && (arg != null)) {
			if(sig->vlist) {
				// TODO check thing like `io:fmt`
				while(arg != null) {
					e:get(chk_expr(env, arg->expr, sig));

					if(pl3:type_is_unk(arg->expr->type))
						e:get(chk_fill(arg->expr, pl3:type_i32));

					arg = arg->next;
				}
			}
			else
				e:fmt("%C: Too many arguments.", pl3:meta_call(&expr->meta));
		}
		else if((arg == null) && (param != null))
			e:fmt("%C: Not enough arguments.", pl3:meta_call(&expr->meta));
	} break;

	case ev:pl3:expr:builtin: {
		var st:pl3:type type;
		var pt:st:pl3:arg arg;
		var pt:st:pl3:builtin builtin = expr->data.builtin;

		if(str:equal(builtin->id, "bi:syscall")) {
			for(arg = builtin->arg; arg != null; arg = arg->next) {
				e:get(chk_expr(env, arg->expr, sig));

				if(pl3:type_is_unk(arg->expr->type))
					e:get(chk_fill(arg->expr, pl3:type_i32));
	
				type = pl3:type_base(arg->expr->type);
				if((type.tag != ev:pl3:type:ptr) && (type.tag != ev:pl3:type:i32) && (type.tag != ev:pl3:type:u32) && (type.tag != ev:pl3:type:i64) && (type.tag != ev:pl3:type:u64))
					e:fmt("%C: Invalid syscall parameter.", pl3:meta_call(&arg->expr->meta));
			}

			pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_void, true)));
		}
		else
			fatal("FIXME unsupported builtin");
	} break;

	case ev:pl3:expr:elem: {
		var en:pl3:tydecl tag;
		var st:pl3:type type;
		var pt:st:pl3:agg agg;
		var pt:st:pl3:err err;
		var pt:st:pl3:field field;
		var pt:st:pl3:elem elem = expr->data.elem;

		e:get(chk_expr(env, elem->expr, sig));
		type = elem->expr->type;

		if(elem->deref) {
			var pt:st:pl3:ptr ptr = pl3:type_get_ptr(type);

			if(ptr == null)
				e:fmt("%C: Cannot dereference a non-pointer type.", pl3:meta_call(&expr->meta));

			e:get(chk_type(env, ptr->type, &expr->meta));
			type = ptr->type;
		}

		if((agg = pl3:type_get_agg(type, &tag)) != null) {
			field = pl3:agg_find(agg, elem->id, &type, &elem->idx);
			if(field == null)
				e:fmt("%C: Cannot find field '%s' in type '%C'.", pl3:meta_call(&elem->expr->meta), elem->id, pl3:type_call(&type));

			
			elem->off = pl3:agg_off(agg, elem->idx, env->ptr);
			pl3:type_replace(&expr->type, pl3:type_copy(type));
			e:get(chk_type(env, expr->type, &expr->meta));
		}
		else if((err = pl3:type_get_err(type)) != null) {
			if(str:equal(elem->id, "val"))
				pl3:type_replace(&expr->type, pl3:type_copy(err->suc));
			else if(str:equal(elem->id, "err"))
				pl3:type_replace(&expr->type, pl3:type_copy(err->fail));
			else
				e:fmt("%C: Only members 'val' and 'err' may be accessed on an error type.", pl3:meta_call(&expr->meta));
		}
		else
			e:fmt("%C: Member access must be on compound type.", pl3:meta_call(&elem->expr->meta));
	} break;

	case ev:pl3:expr:func:
		e:get(chk_func(env, expr->data.func, &expr->meta));
		pl3:type_replace(&expr->type, pl3:type_sig(pl3:sig_copy(expr->data.func->sig)));
		break;

	case ev:pl3:expr:enref:
		e:get(chk_enref(env, expr->data.enref, expr));
		break;

	case ev:pl3:expr:eget: {
		var pt:st:pl3:expr sub;
		var pt:st:pl3:err err;

		sub = expr->data.expr;
		e:get(chk_expr(env, sub, sig));

		err = pl3:type_get_err(sub->type);
		if(err == null)
			e:fmt("%C: Call to `e:get` requires an error type.", pl3:meta_call(&sub->meta));

		// FIXME check return type to match what we e:get
		pl3:type_replace(&expr->type, pl3:type_copy(err->suc));
	} break;

	case ev:pl3:expr:eign: {
		var pt:st:pl3:expr sub;
		var pt:st:pl3:err err;

		sub = expr->data.expr;
		e:get(chk_expr(env, sub, sig));

		err = pl3:type_get_err(sub->type);
		if(err == null)
			e:fmt("%C: Call to `e:ign` requires an error type.", pl3:meta_call(&sub->meta));

		if(!pl3:type_is_void(err->suc))
			e:fmt("%C: Call to `e:ign` requires void error type.", pl3:meta_call(&sub->meta));
		
	} break;

	case ev:pl3:expr:ewarn: {
		fatal("stub ewarn");
	} break;

	case ev:pl3:expr:ereq: {
		var pt:st:pl3:expr sub;
		var pt:st:pl3:err err;

		sub = expr->data.expr;
		e:get(chk_expr(env, sub, sig));

		err = pl3:type_get_err(sub->type);
		if(err == null)
			e:fmt("%C: Call to `e:req` requires an error type.", pl3:meta_call(&sub->meta));

		pl3:type_replace(&expr->type, pl3:type_copy(err->suc));
	} break;

	case ev:pl3:expr:tern: {
		var pt:st:pl3:tern tern = expr->data.tern;

		e:get(chk_expr(env, tern->cond, sig));
		e:get(chk_expr(env, tern->ontrue, sig));
		e:get(chk_expr(env, tern->onfalse, sig));

		// TODO maybe make it not need a boolean?
		if(!pl3:type_is_bool(tern->cond->type))
			e:fmt("%C: Expected boolean.", pl3:meta_call(&tern->cond->meta));
	
		if(pl3:type_is_unk(tern->ontrue->type) && !pl3:type_is_unk(tern->onfalse->type))
			e:get(chk_fill(tern->ontrue, tern->onfalse->type));

		if(pl3:type_is_unk(tern->onfalse->type) && !pl3:type_is_unk(tern->ontrue->type))
			e:get(chk_fill(tern->onfalse, tern->ontrue->type));

		if(!chk_same(tern->ontrue->type, tern->onfalse->type))
			e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&tern->ontrue->type), pl3:type_call(&tern->onfalse->type));

		pl3:type_replace(&expr->type, pl3:type_copy(tern->onfalse->type));
	} break;

	case ev:pl3:expr:size: {
		var pt:st:pl3:size size = expr->data.size;

		if(size->expr != null) {
			e:get(chk_expr(env, size->expr, sig));

			if(pl3:type_is_unk(size->expr->type))
				e:fmt("%C: Cannot take sizeof unresolved type.", pl3:meta_call(&expr->meta));

			size->type = pl3:type_copy(size->expr->type);
		}

		e:get(chk_type(env, size->type, &expr->meta));
	} break;

	case ev:pl3:expr:arrlen: {
		var pt:st:pl3:arr arr;
		var pt:st:pl3:arrlen alen = expr->data.len;

		if(alen->expr != null) {
			e:get(chk_expr(env, alen->expr, sig));

			if(pl3:type_is_unk(alen->expr->type))
				e:fmt("%C: Cannot take `arrlen` of unresolved type.", pl3:meta_call(&expr->meta));

			alen->type = pl3:type_copy(alen->expr->type);
		}

		e:get(chk_type(env, alen->type, &expr->meta));

		if((arr = pl3:type_get_arr(alen->type)) == null)
			e:fmt("%C: Cannot use `arrlen` on non-array type.", pl3:meta_call(&expr->meta));

		alen->val = i32{arr->len};
	} break;

	case ev:pl3:expr:offset: {
		var u32 idx;
		var pt:st:pl3:agg agg;
		var pt:st:pl3:offset offset = expr->data.offset;

		e:get(chk_type(env, offset->type, &expr->meta));

		agg = pl3:type_get_struct(offset->type);
		if(agg == null)
			e:fmt("%C: Type for 'offsetof' must be a structure.", pl3:meta_call(&expr->meta));

		if(pl3:agg_find(agg, offset->id, null, &idx) == null)
			e:fmt("%C: Type '%C' does not have memeber '%s'.", pl3:meta_call(&expr->meta), pl3:type_call(&offset->type), offset->id);

		offset->val = i32{pl3:agg_off(agg, idx, env->ptr)};
	} break;

	case ev:pl3:expr:parent: {
		var u32 idx;
		var st:pl3:type type;
		var pt:st:pl3:agg agg;
		var pt:st:pl3:ptr ptr;
		var pt:st:pl3:parent parent = expr->data.parent;

		e:get(chk_expr(env, parent->expr, sig));
		e:get(chk_type(env, parent->type, &expr->meta));

		agg = pl3:type_get_struct(parent->type);
		if(agg == null)
			e:fmt("%C: Type for 'getparent' must be a structure.", pl3:meta_call(&expr->meta));

		if(pl3:agg_find(agg, parent->id, &type, &idx) == null)
			e:fmt("%C: Type '%C' does not have memeber '%s'.", pl3:meta_call(&expr->meta), pl3:type_call(&parent->type), parent->id);

		if((ptr = pl3:type_get_ptr(parent->expr->type)) == null)
			e:fmt("%C: Expression for 'getparent' must be a pointer.", pl3:meta_call(&parent->expr->meta));

		if(!chk_same(ptr->type, type))
			e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&parent->expr->meta), pl3:type_call(&type), pl3:type_call(&ptr->type));

		parent->off = i32{pl3:agg_off(agg, idx, env->ptr)};
		pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(parent->type), ptr->mut)));
	} break;

	case ev:pl3:expr:vinit:
		pl3:type_replace(&expr->type, pl3:type_args);
		break;

	case ev:pl3:expr:vget: {
		var pt:st:pl3:ptr ptr;
		var pt:st:pl3:vget get = expr->data.vget;

		e:get(chk_expr(env, get->expr, sig));
		e:get(chk_type(env, get->type, &expr->meta));
	
		ptr = pl3:type_get_ptr(get->expr->type);
		if((ptr == null) || (pl3:type_root(ptr->type).tag != ev:pl3:type:args))
			e:fmt("%C: Call to `args:get` requires types `pt:ty:args` as the first parameter.", pl3:meta_call(&expr->meta));

		pl3:type_replace(&expr->type, pl3:type_copy(get->type));
	} break;

	case ev:pl3:expr:getref:
		e:get(chk_expr(env, expr->data.expr, sig));
		pl3:type_replace(&expr->type, pl3:type_ptr(pl3:ptr_new(pl3:type_copy(expr->data.expr->type), false)));
		break;

	default:
		fatal("STUB FIXME chk_expr OK");
	}
};

/**
 * Typecheck an initializer list.
 *   @env: The environment.
 *   @list: The initializer list.
 *   @agg: The aggregate type.
 *   @sig: The function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:list list, pt:st:pl3:agg agg, pt:st:pl3:sig sig) chk_list = {
	var pt:bool set;
	var pt:st:pl3:init init;
	var u32 idx = 0, cnt = pl3:agg_cnt(agg);

	set = mem:alloc(cnt);
	onerr mem:free(set);

	mem:zero(set, cnt);

	for(init = list->init; init != null; init = init->next) {
		var st:pl3:type type;

		//FIXME don't double set a value
		if(init->id != null) {
			if(pl3:agg_find(agg, init->id, &type, &idx) == null)
				e:fmt("%C: Unknown field '%s'.", pl3:meta_call(&init->meta), init->id);
		}
		else if(pl3:agg_get(agg, idx, &type) == null)
			e:fmt("%C: Too many initializers.", pl3:meta_call(&init->meta));

		init->idx = i32{idx};
		init->type = type;
		e:get(chk_type(env, init->type, &init->meta));

		switch(init->tag) {
		case ev:pl3:init:expr: {
			var pt:st:pl3:expr expr = init->data.expr;

			e:get(chk_expr(env, expr, sig));
			if(pl3:type_is_unk(expr->type))
				e:get(chk_fill(expr, type));

			if(!chk_assign(type, expr->type))
				e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&init->meta), pl3:type_call(&type), pl3:type_call(&init->data.expr->type));
		} break;

		case ev:pl3:init:nest: {
			var pt:st:pl3:agg agg;
			var pt:st:pl3:arr arr;

			if((agg = pl3:type_get_agg(type, null)) != null)
				e:get(chk_list(env, init->data.list, agg, sig));
			else if((arr = pl3:type_get_arr(type)) != null)
				e:get(chk_arr(env, init->data.list, arr, sig));
			else
				e:fmt("%C: Invalid initializer.", pl3:meta_call(&init->meta));
		} break;
		}

		set[idx++] = true;
	}

	if(!list->dots) {
		for(idx = 0; idx < cnt; idx++) {
			if(!set[idx] && false) //FIXME use of ... in initializers
				e:fmt("%C: Missing initializer(s).", pl3:meta_call(&list->meta));
		}
	}

	mem:free(set);
};

/**
 * Typecheck an array.
 *   @env: The environment.
 *   @list: The initializer list.
 *   @arr: The array type.
 *   @sig: Optional. The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:list list, pt:st:pl3:arr arr, pt:st:pl3:sig sig) chk_arr = {
	var pt:st:pl3:init init;
	var i32 idx = 0;

	for(init = list->init; init != null; init = init->next) {
		if(init->id != null)
			e:fmt("%C: Cannot have named initializers for arrays.", pl3:meta_call(&init->meta));

		init->idx = idx++;
		init->type = arr->type;

		switch(init->tag) {
		case ev:pl3:init:expr: {
			e:get(chk_expr(env, init->data.expr, sig));

			if(pl3:type_is_unk(init->data.expr->type))
				e:get(chk_fill(init->data.expr, arr->type));

			if(!chk_assign(arr->type, init->data.expr->type))
				e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&init->meta), pl3:type_call(&arr->type), pl3:type_call(&init->data.expr->type));
		} break;

		case ev:pl3:init:nest:
			e:get(chk_init(env, init->data.list, arr->type, sig));
		}
	}
};

/**
 * Check an initializer list.
 *   @env: The environment.
 *   @list: The initializer list.
 *   @type: The type.
 *   @sig: Optional. The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:list list, st:pl3:type type, pt:st:pl3:sig sig) chk_init = {
	var pt:st:pl3:agg agg;
	var pt:st:pl3:arr arr;

	if((agg = pl3:type_get_agg(type, null)) != null)
		e:get(chk_list(env, list, agg, sig));
	else if((arr = pl3:type_get_arr(type)) != null)
		e:get(chk_arr(env, list, arr, sig));
};

/**
 * Typecheck a cast.
 *   @env: The environment.
 *   @expr: The cast expression.
 *   @type: The target type.
 *   @sig: Optional. The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:expr expr, st:pl3:type type, pt:st:pl3:sig sig) chk_cast = {
	e:get(chk_expr(env, expr, sig));
	if(pl3:type_is_comp(expr->type))
		e:fmt("%C: Invalid cast. Source expression cannot be a compound type.", pl3:meta_call(&expr->meta));

	if(pl3:type_is_unk(expr->type))
		e:get(chk_fill(expr, type));
};

/**
 * Typecheck a function.
 *   @env: The environment.
 *   @func: The function.
 *   @meta: The metadata.
 */
def e:str[void](pt:st:env env, pt:st:pl3:func func, pt:st:pl3:meta meta) chk_func = {
	var st:env nest;
	var pt:st:pl3:param param;

	e:get(chk_sig(env, func->sig, meta));

	nest = env_func(env);
	onerr env_done(nest);

	for(param = func->sig->param; param != null; param = param->next) {
		if(param->id != null)
			e:get(add_param(&nest, param));
	}

	e:get(chk_block(&nest, &func->block, func->sig));
	env_done(nest);
};

// FIXME below
def[export] pt:char(cpt:char str, char ch) chr = {
	var u32 i;

	for(i = 0; str[i] != '\0'; i++) {
		if(str[i] == ch)
			return str + i;
	}

	return null;
};
def[export] pt:char(cpt:char str, char ch) rchr = {
	var u32 i;

	for(i = str:len(str) - 1; i != -1; i--) {
		if(str[i] == ch)
			return str + i;
	}

	return null;
};
def[export] pt:char(cpt:char str, cpt:char sought) str:find = {
	var u32 i, len;

	len = str:len(sought);

	for(i = 0; str[i] != '\0'; i++) {
		if(mem:cmp(str + i, sought, len) == 0)
			return str + i;
	}

	return null;
};
def[export] pt:char(cpt:char str, cpt:char sought) str:rfind = {
	var u32 i, len;

	len = str:len(sought);

	for(i = str:len(str) - 1; i != -1; i--) {
		if(mem:cmp(str + i, sought, len) == 0)
			return str + i;
	}

	return null;
};

/**
 * Duplicate a string with a maximum length.
 *   @str: The string.
 *   @max: The maximum length.
 *   &returns: The duplicated string.
 */
def[export] bool(cpt:char str, cpt:char delim, pt:pt:char lhs, pt:pt:char rhs) str:rsplit2 = {
	var cpt:char find;

	find = str:rfind(str, delim);
	if(find == null)
		return false;

	*lhs = str:ndup(str, u32{find - str});
	*rhs = str:dup(find + str:len(delim));
	return true;
};

/**
 * Typecheck an enumerated reference.
 *   @env: The environment.
 *   @func: The function.
 *   @expr: The original expression.
 */
def e:str[void](pt:st:env env, pt:st:pl3:enref ref, pt:st:pl3:expr expr) chk_enref = {
	var pt:char pre, post, name;
	var pt:st:pl3:tydecl decl;

	if(!str:rsplit2(ref->id, ":", &pre, &post))
		e:fmt("%C: Invalid enumerated type. Missing ':'.", pl3:meta_call(&expr->meta));

	name = str:fmt("en:%s", pre);
	onerr mem:free(pre);
	onerr mem:free(post);
	onerr mem:free(name);

	decl = get_type(env, name);
	if(decl == null) {
		//FIXME c'mon
		var pt:char str = str:fmt("%C: Unknown enumerator '%s' for value 'ev:%s' %d.", pl3:meta_call(&expr->meta), name, ref->id);
		e:ret(str);
	}
	else if(decl->tag != ev:pl3:tydecl:enum) {
		//FIXME c'mon
		var pt:char str = str:fmt("%C: Internal error. Invalid type declaration found.", pl3:meta_call(&expr->meta));
		e:ret(str);
	}

	ref->val = pl3:enum_find(decl->data.enum, post);
	if(ref->val == null) {
		//FIXME c'mon
		var pt:char str = str:fmt("%C: Unknown value '%s' for enumerator '%s'", pl3:meta_call(&expr->meta), post, name);
		e:ret(str);
	}

	pl3:type_replace(&expr->type, pl3:type_name(pl3:name_new(name, decl)));

	mem:free(pre);
	mem:free(post);
};


/**
 * Typecheck a statement.
 *   @env: The environment.
 *   @stmt: The statement.
 *   @sig: Optional. The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:stmt stmt, pt:st:pl3:sig sig) chk_stmt = {
	switch(stmt->tag) {
	case ev:pl3:stmt:empty:
		break;

	case ev:pl3:stmt:decl: {
		var pt:st:pl3:bind bind;
		var pt:st:pl3:decl decl = stmt->data.decl;

		for(bind = decl->bind; bind != null; bind = bind->next)
			e:get(add_ref(env, decl, bind));

		e:get(chk_decl(env, decl, sig));
	} break;

	case ev:pl3:stmt:tydecl:
		e:get(add_type(env, stmt->data.tydecl));
		e:get(chk_tydecl(env, stmt->data.tydecl, sig));
		break;

	case ev:pl3:stmt:expr:
		e:get(chk_expr(env, stmt->data.expr, sig));
		break;

	case ev:pl3:stmt:ret: {
		var pt:st:pl3:expr expr = stmt->data.expr;

		if(sig == null)
			e:fmt("%C: Return must be inside a function.", pl3:meta_call(&stmt->meta));

		if(expr != null) {
			e:get(chk_expr(env, expr, sig));

			if(pl3:type_is_unk(expr->type)) {
				var pt:st:pl3:err err;
				var st:pl3:type type;

				err = pl3:type_get_err(sig->ret);
				type = (err != null) ? err->suc : sig->ret;
				e:get(chk_fill(expr, pl3:type_is_void(type) ? pl3:type_u32 : type));
			}

			if(pl3:type_is_void(sig->ret) && !pl3:type_is_void(expr->type))
				e:fmt("%C: Cannot return a value from a void function.", pl3:meta_call(&stmt->meta));
		}
		else {
			var pt:st:pl3:err err;

			if((err = pl3:type_get_err(sig->ret)) != null) {
				if(!pl3:type_is_void(err->suc))
					e:fmt("%C: Non-void function must return a value.", pl3:meta_call(&stmt->meta));
			}
			else if(!pl3:type_is_void(sig->ret))
				e:fmt("%C: Non-void function must return a value.", pl3:meta_call(&stmt->meta));
		}
	} break;

	case ev:pl3:stmt:cond: {
		var pt:st:pl3:cond cond = stmt->data.cond;

		e:get(chk_expr(env, cond->eval, sig));

		if(pl3:type_is_unk(cond->eval->type))
			e:get(chk_fill(cond->eval, pl3:type_bool));

		if(!pl3:type_is_bool(cond->eval->type))
			e:fmt("%C: Expected boolean.", pl3:meta_call(&cond->eval->meta));

		if(cond->ontrue != null)
			e:get(chk_stmt(env, cond->ontrue, sig));

		if(cond->onfalse != null)
			e:get(chk_stmt(env, cond->onfalse, sig));
	} break;

	case ev:pl3:stmt:block:
		e:get(chk_block(env, &stmt->data.block, sig));
		break;

	case ev:pl3:stmt:loop: {
		var st:env nest;
		var pt:st:pl3:loop loop = stmt->data.loop;

		if(loop->init != null)
			e:get(chk_expr(env, loop->init, sig));

		if(loop->eval != null) {
			e:get(chk_expr(env, loop->eval, sig));

			if(!pl3:type_is_bool(loop->eval->type))
				e:fmt("%C: Expected boolean.", pl3:meta_call(&loop->eval->meta));
		}

		if(loop->inc != null)
			e:get(chk_expr(env, loop->inc, sig));

		nest = env_loop(env);
		e:get(chk_stmt(&nest, loop->body, sig));
	} break;

	case ev:pl3:stmt:sw: {
		var st:env nest;
		var pt:st:pl3:sw sw = stmt->data.sw;

		e:get(chk_expr(env, sw->eval, sig));

		if(pl3:type_is_unk(sw->eval->type))
			e:get(chk_fill(sw->eval, pl3:type_i32));

		nest = env_sw(env, sw);
		e:get(chk_stmt(&nest, sw->stmt, sig));
	} break;

	case ev:pl3:stmt:cas: {
		var pt:st:pl3:sw sw = get_sw(env);
		var pt:st:pl3:cas cas = stmt->data.cas;

		if(sw == null)
			e:fmt("%C: Case statement not within switch.", pl3:meta_call(&stmt->meta));

		e:get(chk_expr(env, cas->expr, sig));
		if(pl3:type_is_unk(cas->expr->type))
			e:get(chk_fill(cas->expr, sw->eval->type));

		cas->next = sw->cas;
		sw->cas = cas;
	} break;

	case ev:pl3:stmt:dflt: {
		var pt:st:pl3:sw sw = get_sw(env);

		if(sw == null)
			e:fmt("%C: Default statement not within switch.", pl3:meta_call(&stmt->meta));
		else if(sw->dflt != null)
			e:fmt("%C: Duplicate default statement.", pl3:meta_call(&stmt->meta));

		sw->dflt = stmt;
	} break;

	case ev:pl3:stmt:brk:
	case ev:pl3:stmt:cont: {
		var pt:st:env iter;
		var u32 cnt = 0;

		for(iter = env; iter != null; iter = iter->up) {
			if(iter->tag == ev:env:func)
				break;
			else if((iter->tag == ev:env:loop) || (iter->tag == ev:env:sw))
				cnt++;
		}

		if(stmt->data.depth > cnt)
			e:fmt("%C: Cannot `%s` with depth `%u`.", pl3:meta_call(&stmt->meta), (stmt->tag == ev:pl3:stmt:brk) ? "break" : "continue", stmt->data.depth);
	} break;

	case ev:pl3:stmt:eret: {
		var pt:st:pl3:expr sub;
		var pt:st:pl3:err err;

		sub = stmt->data.expr;
		e:get(chk_expr(env, sub, sig));

		err = pl3:type_get_err(sig->ret);
		if(err == null)
			e:fmt("%C: The function must return an error type to use `e:ret`.", pl3:meta_call(&sub->meta));

		if(pl3:type_is_unk(sub->type))
			e:get(chk_fill(sub, err->fail));

		if(!chk_assign(err->fail, sub->type))
			e:fmt("%C: Type mismatch between '%C' and '%C'.", pl3:meta_call(&sub->meta), pl3:type_call(&err->fail), pl3:type_call(&sub->type));
	} break;

	case ev:pl3:stmt:onerr:
		e:get(chk_stmt(env, stmt->data.stmt, sig));
		break;

	default:
		fatal("STUB FIXME chk_stmt OK");
	}
};

/**
 * Typecheck a block.
 *   @env: The environment.
 *   @block: The code block.
 *   @sig: Optional. The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:block block, pt:st:pl3:sig sig) chk_block = {
	var st:env nest;
	var pt:st:pl3:stmt stmt;

	nest = env_block(env);
	onerr env_done(nest);

	for(stmt = block->stmt; stmt != null; stmt = stmt->next)
		e:get(chk_stmt(&nest, stmt, sig));

	env_done(nest);
};


/**
 * Perform a typefilll on an expression.
 *   @expr: The expression.
 *   @type: The type to fill.
 */
def e:str[void](pt:st:pl3:expr expr, st:pl3:type type) chk_fill = {
	if(pl3:type_is_unk(type) || !pl3:type_is_unk(expr->type))
		return;

	switch(expr->tag) {
	case ev:pl3:expr:lit:
		if(!pl3:lit_fill(expr->data.lit, type))
			e:fmt("%C: Cannot convert type '%C' to '%C'.", pl3:meta_call(&expr->meta), pl3:type_call(&expr->type), pl3:type_call(&type));

		pl3:type_replace(&expr->type, pl3:type_copy(type));
		break;

	case ev:pl3:expr:ident:
		e:fmt("%C: Unknown type for identifier `%s`.", pl3:meta_call(&expr->meta), expr->data.ident->str);

	case ev:pl3:expr:size:
	case ev:pl3:expr:arrlen:
	case ev:pl3:expr:offset:
		pl3:type_replace(&expr->type, pl3:type_copy(type));
		break;

	case ev:pl3:expr:tern: {
		var pt:st:pl3:tern tern = expr->data.tern;

		e:get(chk_fill(tern->ontrue, type));
		e:get(chk_fill(tern->onfalse, type));
		pl3:type_replace(&expr->type, pl3:type_copy(tern->ontrue->type));
	} break;

	case ev:pl3:expr:op1:
		e:get(chk_fill(expr->data.op1->in, type));
		pl3:type_replace(&expr->type, pl3:type_copy(expr->data.op1->in->type));
		break;

	case ev:pl3:expr:op2: {
		var pt:st:pl3:op2 op2 = expr->data.op2;

		e:get(chk_fill(op2->lhs, type));
		e:get(chk_fill(op2->rhs, type));
		pl3:type_replace(&expr->type, pl3:type_copy(op2->lhs->type));
	} break;

	case ev:pl3:expr:func:
	case ev:pl3:expr:comp:
	case ev:pl3:expr:elem:
	case ev:pl3:expr:call:
	case ev:pl3:expr:enref:
	case ev:pl3:expr:eget:
	case ev:pl3:expr:ereq:
	case ev:pl3:expr:index:
	case ev:pl3:expr:parent:
		break;
	}
};


/**
 * Typecheck a type declaration.
 *   @env: The environment.
 *   @decl: The declaration.
 *   @sig: Optional. The current function signature.
 */
def e:str[void](pt:st:env env, pt:st:pl3:tydecl decl, pt:st:pl3:sig sig) chk_tydecl = {
	switch(decl->tag) {
	case ev:pl3:tydecl:alias:
		e:get(chk_type(env, decl->data.alias->type, &decl->meta));
		break;

	case ev:pl3:tydecl:struct:
	case ev:pl3:tydecl:union:
		e:get(chk_agg(env, decl->data.agg, &decl->meta));
		break;

	case ev:pl3:tydecl:enum:
		e:get(chk_enum(env, decl->data.enum, decl, &decl->meta));
		break;
	}
};

/**
 * Typecheck a type.
 *   @env: The environment.
 *   @type: The type.
 *   @meta: The metadata for error reporting.
 */
def e:str[void](pt:st:env env, st:pl3:type type, pt:st:pl3:meta meta) chk_type = {
	switch(type.tag) {
	case ev:pl3:type:name: {
		var pt:st:pl3:tydecl decl;
		var pt:st:pl3:name name = type.data.name;

		decl = get_type(env, name->id);
		if(decl == null)
			e:fmt("%C: Unknown type '%s'.", pl3:meta_call(meta), name->id);

		name->decl = decl;
	} break;

	case ev:pl3:type:ptr:
		e:get(chk_type(env, type.data.ptr->type, meta));
		break;

	case ev:pl3:type:arr:
		e:get(chk_type(env, type.data.arr->type, meta));
		break;

	case ev:pl3:type:sig:
		e:get(chk_sig(env, type.data.sig, meta));
		break;

	case ev:pl3:type:err:
		e:get(chk_type(env, type.data.err->suc, meta));
		e:get(chk_type(env, type.data.err->fail, meta));
		break;
	}
};

/**
 * Typecheck a function signature.
 *   @env: The environment.
 *   @sig: The function signature.
 *   @meta: The metadata.
 */
def e:str[void](pt:st:env env, pt:st:pl3:sig sig, pt:st:pl3:meta meta) chk_sig = {
	var pt:st:pl3:param param;

	e:get(chk_type(env, sig->ret, meta));

	for(param = sig->param; param != null; param = param->next)
		e:get(chk_type(env, param->type, meta));
};

/**
 * Typecheck an aggregate type.
 *   @ctx: The context.
 *   @env: The environment.
 *   @agg: The aggregate type.
 *   @meta: The metadata.
 */
def e:str[void](pt:st:env env, pt:st:pl3:agg agg, pt:st:pl3:meta meta) chk_agg = {
	var pt:st:pl3:memb memb;

	for(memb = agg->memb; memb != null; memb = memb->next)
		e:get(chk_type(env, memb->type, meta));
};

/**
 * Typecheck an enumerator.
 *   @ctx: The context.
 *   @env: The environment.
 *   @enum: The enumerator type.
 *   @meta: The metadata.
 */
// TODO we should use wide constants (using constant folding) instead of expressions
def e:str[void](pt:st:env env, pt:st:pl3:enum enum, pt:st:pl3:tydecl decl, pt:st:pl3:meta meta) chk_enum = {
	var i32 n = 0;
	var pt:st:pl3:enval val, iter;

	for(val = enum->val; val != null; val = val->next) {
		for(iter = enum->val; iter != val; iter = iter->next) {
			if(str:equal(iter->id, val->id))
				e:fmt("%C: Duplicate value '%s'.", pl3:meta_call(&iter->meta), val->id);
		}

		if(val->expr == null)
			val->expr = pl3:expr_lit(pl3:lit_i32(n++), pl3:meta_copy(*meta));
		else
			fatal("STUB chk_enum w/expr");

		pl3:type_replace(&val->expr->type, pl3:type_i32);
	}
};


/**
 * Typecheck if two types are the same, verifying const correctness.
 *   @lhs: The left-hand side type.
 *   @rhs; The right-hand side type.
 *   &returns: True if check succeeds, false if it fails.
 */
def bool(st:pl3:type lhs, st:pl3:type rhs) chk_same = {
	for() {
		lhs = pl3:type_base(lhs);
		rhs = pl3:type_base(rhs);
		if(lhs.tag != rhs.tag)
			return false;

		if(lhs.tag == ev:pl3:type:ptr) {
			if(lhs.data.ptr->mut != rhs.data.ptr->mut)
				return false;

			lhs = lhs.data.ptr->type;
			rhs = rhs.data.ptr->type;
			if(pl3:type_is_void(lhs) || pl3:type_is_void(rhs) || pl3:type_is_aliased(lhs, rhs))
				return true;
		}
		else if(lhs.tag == ev:pl3:type:sig) {
			var pt:st:pl3:param left, right;

			if(!chk_same(lhs.data.sig->ret, rhs.data.sig->ret))
				return false;

			left = lhs.data.sig->param;
			right = lhs.data.sig->param;
			while((left != null) && (right != null)) {
				if((left == null) || (right == null))
					return false;
				else if(!chk_same(left->type, right->type))
					return false;

				left = left->next;
				right = right->next;
			}

			return lhs.data.sig->vlist == rhs.data.sig->vlist;
		}
		else
			return true;
	}
};

/**
 * Typecheck for assignment, verifying const correctness.
 *   @lhs: The left-hand side type.
 *   @rhs; The right-hand side type.
 *   &returns: True if check succeeds, false if it fails.
 */
def bool(st:pl3:type lhs, st:pl3:type rhs) chk_assign = {
	var bool strict = false;

	for() {
		lhs = pl3:type_base(lhs);
		rhs = pl3:type_base(rhs);
		if(lhs.tag != rhs.tag)
			return false;

		if(lhs.tag == ev:pl3:type:ptr) {
			if(lhs.data.ptr->mut && !rhs.data.ptr->mut)
				return false;
			else if(strict && rhs.data.ptr->mut)
				return false;

			strict |= !rhs.data.ptr->mut;
			lhs = lhs.data.ptr->type;
			rhs = rhs.data.ptr->type;
			if(pl3:type_is_void(lhs) || pl3:type_is_void(rhs) || pl3:type_is_aliased(lhs, rhs))
				return true;
		}
		else if(lhs.tag == ev:pl3:type:sig) {
			var pt:st:pl3:param left, right;

			if(!chk_assign(lhs.data.sig->ret, rhs.data.sig->ret))
				return false;

			left = lhs.data.sig->param;
			right = lhs.data.sig->param;
			while((left != null) && (right != null)) {
				if((left == null) || (right == null))
					return false;
				else if(!chk_assign(left->type, right->type))
					return false;

				left = left->next;
				right = right->next;
			}

			return lhs.data.sig->vlist == rhs.data.sig->vlist;
		}
		else if(lhs.tag == ev:pl3:type:name)
			return str:equal(lhs.data.name->id, rhs.data.name->id);
		else
			return true;
	}
};

/**
 * Typecheck for comparison, ignoring const correctness
 *   @lhs: The left-hand side type.
 *   @rhs; The right-hand side type.
 *   &returns: True if check succeeds, false if it fails.
 */
def bool(st:pl3:type lhs, st:pl3:type rhs) chk_cmp = {
	for() {
		lhs = pl3:type_base(lhs);
		rhs = pl3:type_base(rhs);
		if(lhs.tag != rhs.tag)
			return false;

		if(lhs.tag == ev:pl3:type:ptr) {
			lhs = lhs.data.ptr->type;
			rhs = rhs.data.ptr->type;
			if(pl3:type_is_void(lhs) || pl3:type_is_void(rhs) || pl3:type_is_aliased(lhs, rhs))
				return true;
		}
		else if(lhs.tag == ev:pl3:type:sig) {
			var pt:st:pl3:param left, right;

			if(!chk_cmp(lhs.data.sig->ret, rhs.data.sig->ret))
				return false;

			left = lhs.data.sig->param;
			right = lhs.data.sig->param;
			while((left != null) && (right != null)) {
				if((left == null) || (right == null))
					return false;
				else if(!chk_cmp(left->type, right->type))
					return false;

				left = left->next;
				right = right->next;
			}

			return lhs.data.sig->vlist == rhs.data.sig->vlist;
		}
		else
			return true;
	}
};


/**
 * Create the top level environment.
 *   @ptr: The pointer size.
 *   &returns: The environment.
 */
def st:env(u32 ptr) env_top = {
	return st:env{ ptr, ev:env:block, { .map = map_new(false, null) }, null };
};

/**
 * Create a nested function environment.
 *   @env: The environment.
 *   &returns: The nested environment.
 */
def st:env(pt:st:env env) env_func = {
	return st:env{ env->ptr, ev:env:func, { .map = map_new(false, null) }, env };
};

/**
 * Create a nested block environment.
 *   @env: The environment.
 *   &returns: The nested environment.
 */
def st:env(pt:st:env env) env_block  = {
	return st:env{ env->ptr, ev:env:block, { .map = map_new(false, null) }, env };
};

/**
 * Create a swing environment.
 *   @env: The environment.
 *   &returns: The nested environment.
 */
def st:env(pt:st:env env, pt:st:pl3:sw sw) env_sw = {
	return st:env{ env->ptr, ev:env:sw, { .sw = sw }, env };
};

/**
 * Create a loop environment.
 *   @env: The environment.
 *   &returns: The nested environment.
 */
def st:env(pt:st:env env) env_loop = {
	return st:env{ env->ptr, ev:env:loop, {}, env };
};

/**
 * Done with an environment, cleaning up data.
 *   @env: The environment.
 */
def void(st:env env) env_done = {
	if((env.tag == ev:env:func) || (env.tag == ev:env:block))
		map_delete(env.data.map);
};


/**
 * Retrieve the first map from an environment.
 *   @env: The environment.
 *   &returns: The map.
 */
def pt:st:map(pt:st:env env) get_map = {
	while(env->up != null) {
		if((env->tag == ev:env:func) || (env->tag == ev:env:block))
			break;

		env = env->up;
	}

	if((env->tag != ev:env:func) && (env->tag != ev:env:block))
		unreachable();

	return env->data.map;
};

/**
 * Retrieve the first map from an environment.
 *   @env: The environment.
 *   &returns: The map.
 */
def pt:st:pl3:sw(pt:st:env env) get_sw = {
	while(env != null) {
		if(env->tag == ev:env:sw)
			return env->data.sw;
		else if(env->tag == ev:env:func)
			return null;

		env = env->up;
	}

	return null;
};


/**
 * Retrieve a type from the environment.
 *   @env: The environment.
 *   @id: The identifier.
 *   &returns: The type declaration or null if not found.
 */
def pt:st:pl3:tydecl(pt:st:env env, cpt:char id) get_type = {
	var pt:st:avl:node node;

	while(env != null) {
		if((env->tag == ev:env:func) || (env->tag == ev:env:block)) {
			node = avl:root_get(&env->data.map->type, id);
			if(node != null)
				return getparent(node, st:type, node)->decl;
		}

		env = env->up;
	}

	return null;
};

/**
 * Retrieve a symbol from the environment.
 *   @env: The environment.
 *   @id: The identifier.
 *   &returns: The symbol declaration or null if not found.
 */
def pt:st:sym(pt:st:env env, cpt:char id) get_sym = {
	var pt:st:sym sym;
	var pt:st:avl:node node;
	var bool any = true;

	while(env != null) {
		if((env->tag == ev:env:func) || (env->tag == ev:env:block)) {
			node = avl:root_get(&env->data.map->sym, id);
			if(node != null) {
				sym = getparent(node, st:sym, node);
				if(!sym_mut(sym) || (env->up == null) || (env->up->up == null) || any)
					return sym;
			}

			if(env->tag == ev:env:func)
				any = false;
		}

		env = env->up;
	}

	return null;
};


/**
 * Add a paramater to a map.
 *   @map: The map.
 *   @param: The paramater.
 */
def e:str[void](pt:st:env env, pt:st:pl3:param param) add_param = {
	var pt:st:sym name;
	var pt:st:map map = get_map(env);

	name = mem:make(st:sym{ ev:sym:param, 0, { .param = param }, avl:node(param->id) });
	avl:root_add(&map->sym, &name->node);
};

/**
 * Add a declaration to a map (recursiving over bindings).
 *   @env: The environment.
 *   @decl: The declaration.
 */
def e:str[void](pt:st:env env, pt:st:pl3:decl decl) add_decl = {
	var pt:st:pl3:bind bind;

	for(bind = decl->bind; bind != null; bind = bind->next)
		e:get(add_ref(env, decl, bind));
};

/**
 * Add a reference to a map.
 *   @env: The environment.
 *   @decl: The declaration.
 *   @bind: The binding.
 */
def e:str[void](pt:st:env env, pt:st:pl3:decl decl, pt:st:pl3:bind bind) add_ref = {
	var pt:st:sym sym;
	var pt:st:avl:node node;
	var pt:st:map map = get_map(env);

	node = avl:root_get(&env->data.map->sym, bind->id);
	if(node != null) {
		sym = getparent(node, st:sym, node);
		if(sym->tag == ev:sym:ref) {
			if(sym_ext(sym) != 0) {
				sym->data.ref.bind->redef = true;
				sym->data.ref = st:ref{ decl, bind };
				return;
			}
			else if((decl->flags & pl3:decl:ext) != 0) {
				bind->redef = true;
				return;
			}
		}
			
		e:fmt("%C: Duplicate declaration '%s'.", pl3:meta_call(&decl->meta), bind->id);
	}

	sym = mem:make(st:sym{ ev:sym:ref, 0, { .ref = { decl, bind } }, avl:node(bind->id) });
	avl:root_add(&map->sym, &sym->node);
};

/**
 * Add a type to a map.
 *   @env: The environment.
 *   @decl: The type declaration.
 */
def e:str[void](pt:st:env env, pt:st:pl3:tydecl decl) add_type = {
	var pt:st:type type;
	var pt:st:avl:node node;
	var pt:st:map map = get_map(env);


	node = avl:root_get(&map->type, decl->id);
	if(node != null) {
		var pt:st:type type = getparent(node, st:type, node);

		if(((type->decl->flags & pl3:decl:exp) != 0) && ((decl->flags & pl3:decl:exp) == 0))
			type->decl = decl;
		else
			e:fmt("%C: Duplicate type declaration '%s'.", pl3:meta_call(&decl->meta), decl->id);
	} else {
		type = mem:make(st:type{ decl, avl:node(decl->id) });
		avl:root_add(&map->type, &type->node);
	}
};


/**
 * Create a map.
 *   @nest: The function nest flag.
 *   @up: The parent map.
 *   &returns: The map.
 */
def pt:st:map(bool nest, pt:st:map up) map_new = {
	return mem:make(st:map{ avl:root_new(&avl:cmp_str), avl:root_new(&avl:cmp_str)});
};

/**
 * Delete a map.
 *   @map: The map.
 */
def void(pt:st:map map) map_delete = {
	avl:root_delete(&map->sym, offsetof(st:sym, node), &mem:free);
	avl:root_delete(&map->type, offsetof(st:type, node), &mem:free);
	mem:free(map);
};
